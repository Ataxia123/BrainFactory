/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  HttpTemplateEditorModal: () => HttpTemplateEditorModal,
  RunPriceAlertModal: () => RunPriceAlertModal,
  default: () => Cannoli
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// node_modules/openai/version.mjs
var VERSION = "4.4.0";

// node_modules/openai/streaming.mjs
var Stream = class {
  constructor(response, controller) {
    this.response = response;
    this.controller = controller;
    this.decoder = new SSEDecoder();
  }
  async *iterMessages() {
    if (!this.response.body) {
      this.controller.abort();
      throw new Error(`Attempted to iterate over a response with no body`);
    }
    const lineDecoder = new LineDecoder();
    const iter = readableStreamAsyncIterable(this.response.body);
    for await (const chunk of iter) {
      for (const line of lineDecoder.decode(chunk)) {
        const sse = this.decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = this.decoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async *[Symbol.asyncIterator]() {
    let done = false;
    try {
      for await (const sse of this.iterMessages()) {
        if (done)
          continue;
        if (sse.data.startsWith("[DONE]")) {
          done = true;
          continue;
        }
        if (sse.event === null) {
          try {
            yield JSON.parse(sse.data);
          } catch (e) {
            console.error(`Could not parse message into JSON:`, sse.data);
            console.error(`From chunk:`, sse.raw);
            throw e;
          }
        }
      }
      done = true;
    } catch (e) {
      if (e instanceof Error && e.name === "AbortError")
        return;
      throw e;
    } finally {
      if (!done)
        this.controller.abort();
    }
  }
};
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new Error(
        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`
      );
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) !== null && _a2 !== void 0 ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new Error(
        `Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`
      );
    }
    throw new Error(
      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`
    );
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "\x85", "\u2028", "\u2029"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result === null || result === void 0 ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/error.mjs
var error_exports = {};
__export(error_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  InternalServerError: () => InternalServerError,
  NotFoundError: () => NotFoundError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError
});
var APIError = class extends Error {
  constructor(status, error, message, headers) {
    super(APIError.makeMessage(error, message));
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data === null || data === void 0 ? void 0 : data["code"];
    this.param = data === null || data === void 0 ? void 0 : data["param"];
    this.type = data === null || data === void 0 ? void 0 : data["type"];
  }
  static makeMessage(error, message) {
    return (error === null || error === void 0 ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message || "Unknown error occurred";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor() {
    super({ message: "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
};
var AuthenticationError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
};
var PermissionDeniedError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
};
var NotFoundError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
};
var ConflictError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
};
var UnprocessableEntityError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
};
var RateLimitError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
};
var InternalServerError = class extends APIError {
};

// node_modules/openai/_shims/agent.mjs
var getDefaultAgent = (url) => {
  return void 0;
};

// node_modules/openai/_shims/fetch.mjs
var _fetch = fetch.bind(void 0);
var isPolyfilled = false;

// node_modules/openai/_shims/formdata.mjs
var _FormData = FormData;
var _File = typeof File !== "undefined" ? File : (
  // Bun doesn't implement File yet, so just make a shim that throws a helpful error message
  class File2 extends Blob {
    constructor() {
      throw new Error(`file uploads aren't supported in this environment yet as 'File' is not defined`);
    }
  }
);

// node_modules/openai/_shims/getMultipartRequestOptions.mjs
async function getMultipartRequestOptions(form, opts) {
  return { ...opts, body: new MultipartBody(form) };
}

// node_modules/openai/_shims/fileFromPath.mjs
async function fileFromPath() {
  throw new Error(
    "The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads"
  );
}

// node_modules/openai/_shims/node-readable.mjs
function isFsReadStream(value) {
  return false;
}

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options = {}) {
  var _a2, _b, _c;
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) !== null && _a2 !== void 0 ? _a2 : "unknown_file");
    return new _File([blob], name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) !== null && _b !== void 0 ? _b : "unknown_file");
  if (!options.type) {
    const type2 = (_c = bits[0]) === null || _c === void 0 ? void 0 : _c.type;
    if (typeof type2 === "string") {
      options = { ...options, type: type2 };
    }
  }
  return new _File(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(
      `Unexpected data type: ${typeof value}; constructor: ${(_a2 = value === null || value === void 0 ? void 0 : value.constructor) === null || _a2 === void 0 ? void 0 : _a2.name}; props: ${propsForError(value)}`
    );
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) === null || _a2 === void 0 ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new _FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(
      `Received null for "${key}"; to pass null in FormData, you must use the string 'null'`
    );
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(
      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop))
    );
  } else {
    throw new TypeError(
      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`
    );
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
var MAX_RETRIES = 2;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    return new Stream(response, props.controller);
  }
  const contentType = response.headers.get("content-type");
  if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) {
    const json2 = await response.json();
    debug("response", response.status, response.url, response.headers, json2);
    return json2;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overridenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger(
      "maxRetries",
      maxRetries !== null && maxRetries !== void 0 ? maxRetries : MAX_RETRIES
    );
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch !== null && overridenFetch !== void 0 ? overridenFetch : _fetch;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 })));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) !== null && _b !== void 0 ? _b : this.httpAgent) !== null && _c !== void 0 ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent === null || httpAgent === void 0 ? void 0 : httpAgent.options) === null || _d === void 0 ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) !== null && _e !== void 0 ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = {
      ...contentLength && { "Content-Length": contentLength },
      ...this.defaultHeaders(options),
      ...headers
    };
    if (isMultipartBody(options.body) && !isPolyfilled) {
      delete reqHeaders["Content-Type"];
    }
    Object.keys(reqHeaders).forEach((key) => reqHeaders[key] === null && delete reqHeaders[key]);
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) !== null && _f !== void 0 ? _f : null
    };
    this.validateHeaders(reqHeaders, headers);
    return { req, url, timeout };
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining = (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : this.maxRetries;
    }
    const { req, url, timeout } = this.buildRequest(options);
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) === null || _c === void 0 ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch(() => "Unknown");
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      debug("response", response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (query) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new Error(
        `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`
      );
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient().fetch(url, { signal: controller.signal, ...options }).finally(() => {
      clearTimeout(timeout);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    retriesRemaining -= 1;
    const retryAfter = parseInt(
      (responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders["retry-after"]) || ""
    );
    const maxRetries = (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : this.maxRetries;
    const timeout = this.calculateRetryTimeoutSeconds(retriesRemaining, retryAfter, maxRetries) * 1e3;
    await sleep(timeout);
    return this.makeRequest(options, retriesRemaining);
  }
  calculateRetryTimeoutSeconds(retriesRemaining, retryAfter, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 2;
    if (Number.isInteger(retryAfter) && retryAfter <= 60) {
      return retryAfter;
    }
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(numRetries - 1, 2), maxRetryDelay);
    const jitter = Math.random() - 0.5;
    return sleepSeconds + jitter;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new Error(
        "No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`."
      );
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo) {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(
      this.constructor,
      nextOptions
    );
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(
      request,
      async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options)
    );
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(
    Object.fromEntries(
      // @ts-ignore
      headers.entries()
    ),
    {
      get(target, name) {
        const key = name.toString();
        return target[key.toLowerCase()] || target[key];
      }
    }
  );
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders !== null && _platformHeaders !== void 0 ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new Error(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new Error(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d;
  if (typeof process !== "undefined") {
    return (_b = (_a2 = process.env) === null || _a2 === void 0 ? void 0 : _a2[env]) !== null && _b !== void 0 ? _b : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_d = (_c = Deno.env) === null || _c === void 0 ? void 0 : _c.get) === null || _d === void 0 ? void 0 : _d.call(_c, env);
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.object = body.object;
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2, _b;
    if (!((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return null;
    }
    const next = (_b = this.data[this.data.length - 1]) === null || _b === void 0 ? void 0 : _b.id;
    if (!next)
      return null;
    return { params: { after: next } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this.client = client;
    this.get = client.get.bind(client);
    this.post = client.post.bind(client);
    this.patch = client.patch.bind(client);
    this.put = client.put.bind(client);
    this.delete = client.delete.bind(client);
    this.getAPIList = client.getAPIList.bind(client);
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  /**
   * Transcribes audio into the input language.
   */
  create(body, options) {
    return this.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Transcriptions2) {
})(Transcriptions || (Transcriptions = {}));

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  /**
   * Translates audio into English.
   */
  create(body, options) {
    return this.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Translations2) {
})(Translations || (Translations = {}));

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this.client);
    this.translations = new Translations(this.client);
  }
};
(function(Audio2) {
  Audio2.Transcriptions = Transcriptions;
  Audio2.Translations = Translations;
})(Audio || (Audio = {}));

// node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2;
    return this.post("/chat/completions", {
      body,
      ...options,
      stream: (_a2 = body.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
(function(Completions3) {
})(Completions || (Completions = {}));

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this.client);
  }
};
(function(Chat2) {
  Chat2.Completions = Completions;
})(Chat || (Chat = {}));

// node_modules/openai/resources/completions.mjs
var Completions2 = class extends APIResource {
  create(body, options) {
    var _a2;
    return this.post("/completions", {
      body,
      ...options,
      stream: (_a2 = body.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
(function(Completions3) {
})(Completions2 || (Completions2 = {}));

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this.post("/embeddings", { body, ...options });
  }
};
(function(Embeddings2) {
})(Embeddings || (Embeddings = {}));

// node_modules/openai/resources/edits.mjs
var Edits = class extends APIResource {
  /**
   * Creates a new edit for the provided input, instruction, and parameters.
   *
   * @deprecated The Edits API is deprecated; please use Chat Completions instead.
   *
   * https://openai.com/blog/gpt-4-api-general-availability#deprecation-of-the-edits-api
   */
  create(body, options) {
    return this.post("/edits", { body, ...options });
  }
};
(function(Edits2) {
})(Edits || (Edits = {}));

// node_modules/openai/resources/files.mjs
var Files = class extends APIResource {
  /**
   * Upload a file that contains document(s) to be used across various
   * endpoints/features. Currently, the size of all the files uploaded by one
   * organization can be up to 1 GB. Please contact us if you need to increase the
   * storage limit.
   */
  create(body, options) {
    return this.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this.get(`/files/${fileId}`, options);
  }
  /**
   * Returns a list of files that belong to the user's organization.
   */
  list(options) {
    return this.getAPIList("/files", FileObjectsPage, options);
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file
   */
  retrieveContent(fileId, options) {
    return this.get(`/files/${fileId}/content`, {
      ...options,
      headers: {
        Accept: "application/json",
        ...options === null || options === void 0 ? void 0 : options.headers
      }
    });
  }
};
var FileObjectsPage = class extends Page {
};
(function(Files2) {
})(Files || (Files = {}));

// node_modules/openai/resources/fine-tunes.mjs
var FineTunes = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
   */
  create(body, options) {
    return this.post("/fine-tunes", { body, ...options });
  }
  /**
   * Gets info about the fine-tune job.
   *
   * [Learn more about fine-tuning](/docs/guides/legacy-fine-tuning)
   */
  retrieve(fineTuneId, options) {
    return this.get(`/fine-tunes/${fineTuneId}`, options);
  }
  /**
   * List your organization's fine-tuning jobs
   */
  list(options) {
    return this.getAPIList("/fine-tunes", FineTunesPage, options);
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuneId, options) {
    return this.post(`/fine-tunes/${fineTuneId}/cancel`, options);
  }
  listEvents(fineTuneId, query, options) {
    var _a2;
    return this.get(`/fine-tunes/${fineTuneId}/events`, {
      query,
      timeout: 864e5,
      ...options,
      stream: (_a2 = query === null || query === void 0 ? void 0 : query.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
var FineTunesPage = class extends Page {
};
(function(FineTunes2) {
})(FineTunes || (FineTunes = {}));

// node_modules/openai/resources/fine-tuning/jobs.mjs
var Jobs = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](/docs/guides/fine-tuning)
   */
  create(body, options) {
    return this.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options) {
    return this.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options) {
    return this.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
(function(Jobs2) {
})(Jobs || (Jobs = {}));

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this.client);
  }
};
(function(FineTuning2) {
  FineTuning2.Jobs = Jobs;
  FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
  FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(FineTuning || (FineTuning = {}));

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options) {
    return this.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options) {
    return this.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options) {
    return this.post("/images/generations", { body, ...options });
  }
};
(function(Images2) {
})(Images || (Images = {}));

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization.
   */
  del(model, options) {
    return this.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {
};
(function(Models2) {
})(Models || (Models = {}));

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text violates OpenAI's Content Policy
   */
  create(body, options) {
    return this.post("/moderations", { body, ...options });
  }
};
(function(Moderations2) {
})(Moderations || (Moderations = {}));

// node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string} [opts.apiKey=process.env['OPENAI_API_KEY']] - The API Key to send to the API.
   * @param {string} [opts.baseURL] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   * @param {string | null} [opts.organization]
   */
  constructor(_b) {
    var _c, _d;
    var {
      apiKey = readEnv("OPENAI_API_KEY"),
      organization = (_c = readEnv("OPENAI_ORG_ID")) !== null && _c !== void 0 ? _c : null,
      ...opts
    } = _b === void 0 ? {} : _b;
    if (apiKey === void 0) {
      throw new Error(
        "The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'my apiKey' })."
      );
    }
    const options = {
      apiKey,
      organization,
      baseURL: `https://api.openai.com/v1`,
      ...opts
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new Error(
        "It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n"
      );
    }
    super({
      baseURL: options.baseURL,
      timeout: (_d = options.timeout) !== null && _d !== void 0 ? _d : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.edits = new Edits(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.fineTunes = new FineTunes(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
var {
  APIError: APIError2,
  APIConnectionError: APIConnectionError2,
  APIConnectionTimeoutError: APIConnectionTimeoutError2,
  APIUserAbortError: APIUserAbortError2,
  NotFoundError: NotFoundError2,
  ConflictError: ConflictError2,
  RateLimitError: RateLimitError2,
  BadRequestError: BadRequestError2,
  AuthenticationError: AuthenticationError2,
  InternalServerError: InternalServerError2,
  PermissionDeniedError: PermissionDeniedError2,
  UnprocessableEntityError: UnprocessableEntityError2
} = error_exports;
(function(OpenAI2) {
  OpenAI2.toFile = toFile;
  OpenAI2.fileFromPath = fileFromPath;
  OpenAI2.Page = Page;
  OpenAI2.CursorPage = CursorPage;
  OpenAI2.Completions = Completions2;
  OpenAI2.Chat = Chat;
  OpenAI2.Edits = Edits;
  OpenAI2.Embeddings = Embeddings;
  OpenAI2.Files = Files;
  OpenAI2.FileObjectsPage = FileObjectsPage;
  OpenAI2.Images = Images;
  OpenAI2.Audio = Audio;
  OpenAI2.Moderations = Moderations;
  OpenAI2.Models = Models;
  OpenAI2.ModelsPage = ModelsPage;
  OpenAI2.FineTuning = FineTuning;
  OpenAI2.FineTunes = FineTunes;
  OpenAI2.FineTunesPage = FineTunesPage;
})(OpenAI || (OpenAI = {}));
var openai_default = OpenAI;

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/canvas.ts
var Canvas = class {
  constructor(canvasFile, subCanvasGroupId) {
    this.canvasFile = canvasFile;
    this.subCanvasGroupId = subCanvasGroupId;
    this.editQueue = Promise.resolve();
  }
  getCanvasData() {
    return this.canvasData;
  }
  async fetchData() {
    const fileContent = await this.canvasFile.vault.cachedRead(
      this.canvasFile
    );
    const parsedContent = JSON.parse(fileContent);
    for (const node of parsedContent.nodes) {
      if (node.type === "group" && (node.label === "cannoli" || node.label === "Cannoli")) {
        this.subCanvasGroupId = node.id;
        break;
      }
    }
    this.canvasData = parsedContent;
    if (this.subCanvasGroupId) {
      const subCanvasGroup = parsedContent.nodes.find(
        (node) => node.id === this.subCanvasGroupId
      );
      if (!subCanvasGroup) {
        throw new Error(
          `Group with id ${this.subCanvasGroupId} not found.`
        );
      }
      const { nodeIds, edgeIds } = this.getNodesAndEdgesInGroup(subCanvasGroup);
      parsedContent.nodes = parsedContent.nodes.filter(
        (node) => nodeIds.includes(node.id)
      );
      parsedContent.edges = parsedContent.edges.filter(
        (edge) => edgeIds.includes(edge.id)
      );
      this.canvasData = parsedContent;
    }
  }
  getNodesAndEdgesInGroup(group) {
    const groupRectangle = this.createRectangle(
      group.x,
      group.y,
      group.width,
      group.height
    );
    const nodeIds = [];
    const edgeIds = [];
    for (const node of this.canvasData.nodes) {
      if (node.id === group.id)
        continue;
      const nodeRectangle = this.createRectangle(
        node.x,
        node.y,
        node.width,
        node.height
      );
      if (this.encloses(groupRectangle, nodeRectangle)) {
        nodeIds.push(node.id);
      } else if (this.overlaps(groupRectangle, nodeRectangle)) {
        throw new Error(
          `Invalid layout: Node with id ${node.id} overlaps with the group but is not fully enclosed. Nodes should be fully inside or outside of each group.`
        );
      }
    }
    for (const edge of this.canvasData.edges) {
      if (nodeIds.includes(edge.fromNode) && nodeIds.includes(edge.toNode)) {
        edgeIds.push(edge.id);
      }
    }
    return { nodeIds, edgeIds };
  }
  createRectangle(x, y, width, height) {
    return {
      x,
      y,
      width,
      height,
      x_right: x + width,
      y_bottom: y + height
    };
  }
  encloses(a, b) {
    return a.x <= b.x && a.y <= b.y && a.x_right >= b.x_right && a.y_bottom >= b.y_bottom;
  }
  overlaps(a, b) {
    const horizontalOverlap = a.x < b.x_right && a.x_right > b.x;
    const verticalOverlap = a.y < b.y_bottom && a.y_bottom > b.y;
    const overlap = horizontalOverlap && verticalOverlap;
    return overlap && !this.encloses(a, b) && !this.encloses(b, a);
  }
  async readCanvasData() {
    const fileContent = await this.canvasFile.vault.read(this.canvasFile);
    return JSON.parse(fileContent);
  }
  async writeCanvasData(data) {
    const newContent = JSON.stringify(data);
    const onEdit = (data2) => {
      return newContent;
    };
    await this.canvasFile.vault.process(this.canvasFile, onEdit);
  }
  changeNodeColor(data, nodeId, newColor) {
    const node = data.nodes.find((node2) => node2.id === nodeId);
    if (node) {
      node.color = newColor;
    }
    return data;
  }
  addErrorNode(data, nodeId, error) {
    const node = data.nodes.find((node2) => node2.id === nodeId);
    const nodeCenterY = node ? node.y + node.height / 2 : 0;
    if (node) {
      const newNodeId = this.generateNewId();
      const errorNode = {
        id: newNodeId,
        x: node.x + node.width + 50,
        y: nodeCenterY - 75,
        width: 500,
        height: 150,
        color: "1",
        text: `<u>Error:</u>
` + error,
        type: "text"
        // Add the 'type' property
      };
      const newEdge = {
        id: this.generateNewId(),
        fromNode: nodeId,
        fromSide: "right",
        toNode: newNodeId,
        toSide: "left",
        fromEnd: "none",
        toEnd: "none",
        color: "1"
        // red color
      };
      data.nodes.push(errorNode);
      data.edges.push(newEdge);
    }
    return data;
  }
  addWarningNode(data, nodeId, error) {
    const node = data.nodes.find((node2) => node2.id === nodeId);
    const nodeCenterY = node ? node.y + node.height / 2 : 0;
    if (node) {
      const newNodeId = this.generateNewId();
      const errorNode = {
        id: newNodeId,
        x: node.x + node.width + 50,
        y: nodeCenterY - 75,
        width: 500,
        height: 150,
        color: "1",
        text: `<u>Warning:</u>
` + error,
        type: "text"
        // Add the 'type' property
      };
      const newEdge = {
        id: this.generateNewId(),
        fromNode: nodeId,
        fromSide: "right",
        toNode: newNodeId,
        toSide: "left",
        fromEnd: "none",
        toEnd: "none",
        color: "1"
        // red color
      };
      const existingWarningNode = data.nodes.find(
        (node2) => node2.x === errorNode.x && node2.y === errorNode.y && node2.width === errorNode.width && node2.height === errorNode.height && node2.text === errorNode.text
      );
      if (existingWarningNode) {
        return null;
      }
      data.nodes.push(errorNode);
      data.edges.push(newEdge);
    }
    return data;
  }
  removeAllErrorNodes(data) {
    const errorNodes = data.nodes.filter(
      (node) => {
        var _a2, _b;
        return node.color === "1" && (((_a2 = node.text) == null ? void 0 : _a2.startsWith("<u>Error:</u>\n")) || ((_b = node.text) == null ? void 0 : _b.startsWith("<u>Warning:</u>\n")));
      }
    );
    const errorEdgeIds = /* @__PURE__ */ new Set();
    errorNodes.forEach((node) => {
      data.edges.forEach((edge) => {
        if (edge.fromNode === node.id || edge.toNode === node.id) {
          errorEdgeIds.add(edge.id);
        }
      });
    });
    data.edges = data.edges.filter((edge) => !errorEdgeIds.has(edge.id));
    data.nodes = data.nodes.filter((node) => !errorNodes.includes(node));
    return data;
  }
  changeNodeText(data, nodeId, newText) {
    const node = data.nodes.find((node2) => node2.id === nodeId);
    if (node) {
      node.text = newText;
    }
    return data;
  }
  async enqueueChangeNodeColor(nodeId, newColor) {
    this.editQueue = this.editQueue.then(async () => {
      const data = await this.readCanvasData();
      const newData = this.changeNodeColor(data, nodeId, newColor);
      await this.writeCanvasData(newData);
    });
    return this.editQueue;
  }
  async enqueueAddErrorNode(nodeId, message) {
    if (nodeId.includes("-")) {
      nodeId = nodeId.split("-")[0];
    }
    this.editQueue = this.editQueue.then(async () => {
      const data = await this.readCanvasData();
      const newData = this.addErrorNode(data, nodeId, message);
      await this.writeCanvasData(newData);
    });
    return this.editQueue;
  }
  async enqueueAddWarningNode(nodeId, message) {
    if (nodeId.includes("-")) {
      nodeId = nodeId.split("-")[0];
    }
    this.editQueue = this.editQueue.then(async () => {
      const data = await this.readCanvasData();
      const newData = this.addWarningNode(data, nodeId, message);
      if (newData) {
        await this.writeCanvasData(newData);
      }
    });
    return this.editQueue;
  }
  async enqueueChangeNodeText(nodeId, newText) {
    this.editQueue = this.editQueue.then(async () => {
      const data = await this.readCanvasData();
      const newData = this.changeNodeText(data, nodeId, newText);
      await this.writeCanvasData(newData);
    });
    return this.editQueue;
  }
  async enqueueRemoveAllErrorNodes() {
    this.editQueue = this.editQueue.then(async () => {
      const data = await this.readCanvasData();
      const newData = this.removeAllErrorNodes(data);
      await this.writeCanvasData(newData);
    });
    return this.editQueue;
  }
  generateNewId() {
    return v4_default().replace(/-/g, "").substring(0, 16);
  }
};

// src/models/object.ts
var CannoliObject = class extends EventTarget {
  constructor(data) {
    super();
    this.id = data.id;
    this.text = data.cannoliData.text;
    this.status = data.cannoliData.status;
    this.dependencies = data.cannoliData.dependencies;
    this.originalObject = data.cannoliData.originalObject;
    this.kind = data.cannoliData.kind;
    this.type = data.cannoliData.type;
    this.canvasData = data;
  }
  setRun(run) {
    this.run = run;
  }
  setGraph(graph, cannoliGraph) {
    this.graph = graph;
    this.cannoliGraph = cannoliGraph;
  }
  setupListeners() {
    for (const dependency of this.dependencies) {
      this.graph[dependency].addEventListener(
        "update",
        (event) => {
          this.dependencyUpdated(
            event.detail.obj,
            event.detail.status
          );
        }
      );
    }
  }
  getAllDependencies() {
    const dependencies = [];
    for (const dependency of this.dependencies) {
      dependencies.push(this.graph[dependency]);
    }
    return dependencies;
  }
  dependencyUpdated(dependency, status) {
    if (this.run.isStopped) {
      return;
    }
    switch (status) {
      case "complete" /* Complete */:
        this.dependencyCompleted(dependency);
        break;
      case "rejected" /* Rejected */:
        this.dependencyRejected(dependency);
        break;
      case "executing" /* Executing */:
        this.dependencyExecuting(dependency);
        break;
      default:
        break;
    }
  }
  allDependenciesComplete() {
    const dependencies = this.getAllDependencies();
    for (const dependency of dependencies) {
      if (dependency.status !== "complete" /* Complete */) {
        if (this.cannoliGraph.isEdge(dependency) && dependency.type !== "logging" /* Logging */) {
          let redundantComplete = false;
          for (const otherDependency of dependencies) {
            if (this.cannoliGraph.isEdge(otherDependency) && otherDependency.text === dependency.text && otherDependency.type === dependency.type && otherDependency.status === "complete" /* Complete */) {
              redundantComplete = true;
              break;
            }
          }
          if (!redundantComplete) {
            return false;
          }
        } else {
          return false;
        }
      }
    }
    return true;
  }
  allEdgeDependenciesComplete() {
    const dependencies = this.getAllDependencies();
    for (const dependency of dependencies) {
      if (!this.cannoliGraph.isEdge(dependency)) {
        continue;
      }
      if (dependency.status !== "complete" /* Complete */) {
        if (this.cannoliGraph.isEdge(dependency) && dependency.type !== "logging" /* Logging */) {
          let redundantComplete = false;
          for (const otherDependency of dependencies) {
            if (this.cannoliGraph.isEdge(otherDependency) && otherDependency.text === dependency.text && otherDependency.status === "complete" /* Complete */) {
              redundantComplete = true;
              break;
            }
          }
          if (!redundantComplete) {
            return false;
          }
        } else {
          return false;
        }
      }
    }
    return true;
  }
  executing() {
    this.status = "executing" /* Executing */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "executing" /* Executing */ }
    });
    this.dispatchEvent(event);
  }
  completed() {
    this.status = "complete" /* Complete */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "complete" /* Complete */ }
    });
    this.dispatchEvent(event);
  }
  pending() {
    this.status = "pending" /* Pending */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "pending" /* Pending */ }
    });
    this.dispatchEvent(event);
  }
  reject() {
    this.status = "rejected" /* Rejected */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "rejected" /* Rejected */ }
    });
    this.dispatchEvent(event);
  }
  tryReject() {
    const shouldReject = this.getAllDependencies().every((dependency) => {
      if (dependency.status === "rejected" /* Rejected */) {
        if (this.cannoliGraph.isEdge(dependency)) {
          let redundantNotRejected = false;
          for (const otherDependency of this.getAllDependencies()) {
            if (this.cannoliGraph.isEdge(otherDependency) && otherDependency.text === dependency.text && otherDependency.status !== "rejected" /* Rejected */) {
              redundantNotRejected = true;
              break;
            }
          }
          if (redundantNotRejected) {
            return true;
          }
        }
        return false;
      }
      return true;
    });
    if (!shouldReject) {
      this.reject();
    }
  }
  ensureStringLength(str2, maxLength) {
    if (str2.length > maxLength) {
      return str2.substring(0, maxLength - 3) + "...";
    } else {
      return str2;
    }
  }
  reset() {
    this.status = "pending" /* Pending */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "pending" /* Pending */ }
    });
    this.dispatchEvent(event);
  }
  dependencyRejected(dependency) {
    this.tryReject();
  }
  dependencyCompleted(dependency) {
  }
  dependencyExecuting(dependency) {
  }
  async execute() {
  }
  logDetails() {
    let dependenciesString = "";
    for (const dependency of this.dependencies) {
      dependenciesString += `	"${this.graph[dependency].text}"
`;
    }
    return `Dependencies:
${dependenciesString}
`;
  }
  validate() {
  }
};
var CannoliVertex = class extends CannoliObject {
  // Sorted from immediate parent to most distant
  constructor(vertexData) {
    super(vertexData);
    this.outgoingEdges = vertexData.cannoliData.outgoingEdges;
    this.incomingEdges = vertexData.cannoliData.incomingEdges;
    this.groups = vertexData.cannoliData.groups;
  }
  getOutgoingEdges() {
    return this.outgoingEdges.map(
      (edge) => this.graph[edge]
    );
  }
  getIncomingEdges() {
    return this.incomingEdges.map(
      (edge) => this.graph[edge]
    );
  }
  getGroups() {
    return this.groups.map((group) => this.graph[group]);
  }
  createRectangle(x, y, width, height) {
    return {
      x,
      y,
      width,
      height,
      x_right: x + width,
      y_bottom: y + height
    };
  }
  encloses(a, b) {
    return a.x <= b.x && a.y <= b.y && a.x_right >= b.x_right && a.y_bottom >= b.y_bottom;
  }
  overlaps(a, b) {
    const horizontalOverlap = a.x < b.x_right && a.x_right > b.x;
    const verticalOverlap = a.y < b.y_bottom && a.y_bottom > b.y;
    const overlap = horizontalOverlap && verticalOverlap;
    return overlap && !this.encloses(a, b) && !this.encloses(b, a);
  }
  error(message) {
    this.status = "error" /* Error */;
    const event = new CustomEvent("update", {
      detail: {
        obj: this,
        status: "error" /* Error */,
        message
      }
    });
    this.dispatchEvent(event);
    console.error(message);
  }
  warning(message) {
    this.status = "warning" /* Warning */;
    const event = new CustomEvent("update", {
      detail: {
        obj: this,
        status: "warning" /* Warning */,
        message
      }
    });
    this.dispatchEvent(event);
    console.error(message);
  }
  validate() {
    super.validate();
  }
};

// src/models/group.ts
var CannoliGroup = class extends CannoliVertex {
  constructor(groupData) {
    var _a2, _b;
    super(groupData);
    this.members = groupData.cannoliData.members;
    this.maxLoops = (_a2 = groupData.cannoliData.maxLoops) != null ? _a2 : 1;
    this.currentLoop = (_b = groupData.cannoliData.currentLoop) != null ? _b : 0;
  }
  getMembers() {
    return this.members.map(
      (member) => this.graph[member]
    );
  }
  getCrossingAndInternalEdges() {
    const crossingInEdges = [];
    const crossingOutEdges = [];
    const internalEdges = [];
    for (const member of this.members) {
      const memberObject = this.graph[member];
      if (this.cannoliGraph.isNode(memberObject) || this.cannoliGraph.isGroup(memberObject)) {
        for (const edge of memberObject.incomingEdges) {
          const edgeObject = this.graph[edge];
          if (this.cannoliGraph.isEdge(edgeObject)) {
            if (edgeObject.crossingInGroups.includes(this.id)) {
              crossingInEdges.push(edgeObject);
            } else {
              internalEdges.push(edgeObject);
            }
          }
        }
        for (const edge of memberObject.outgoingEdges) {
          const edgeObject = this.graph[edge];
          if (this.cannoliGraph.isEdge(edgeObject)) {
            if (edgeObject.crossingOutGroups.includes(this.id)) {
              crossingOutEdges.push(edgeObject);
            } else {
              internalEdges.push(edgeObject);
            }
          }
        }
      }
    }
    return {
      crossingInEdges,
      crossingOutEdges,
      internalEdges
    };
  }
  allMembersCompleteOrRejected() {
    for (const member of this.members) {
      if (this.graph[member].status !== "complete" /* Complete */ && this.graph[member].status !== "rejected" /* Rejected */) {
        return false;
      }
    }
    return true;
  }
  allDependenciesCompleteOrRejected() {
    for (const dependency of this.dependencies) {
      if (this.graph[dependency].status !== "complete" /* Complete */ && this.graph[dependency].status !== "rejected" /* Rejected */) {
        return false;
      }
    }
    return true;
  }
  async execute() {
    this.status = "complete" /* Complete */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "complete" /* Complete */ }
    });
    this.dispatchEvent(event);
  }
  membersFinished() {
  }
  dependencyCompleted(dependency) {
    if (this.status === "executing" /* Executing */) {
      if (this.allDependenciesCompleteOrRejected()) {
        this.membersFinished();
      }
    }
  }
  dependencyExecuting(dependency) {
    if (this.status === "pending" /* Pending */) {
      this.execute();
    }
  }
  dependencyRejected(dependency) {
    if (this.noEdgeDependenciesRejected()) {
      return;
    } else {
      this.reject();
    }
  }
  noEdgeDependenciesRejected() {
    for (const dependency of this.dependencies) {
      if (this.graph[dependency].kind === "edge") {
        if (this.graph[dependency].status === "rejected" /* Rejected */) {
          return false;
        }
      }
    }
    return true;
  }
  anyReflexiveEdgesComplete() {
    for (const edge of this.incomingEdges) {
      const edgeObject = this.graph[edge];
      if (edgeObject.isReflexive && edgeObject.status === "complete" /* Complete */) {
        return true;
      }
    }
    return false;
  }
  logDetails() {
    let groupsString = "";
    groupsString += `Groups: `;
    for (const group of this.groups) {
      groupsString += `
	-"${this.ensureStringLength(
        this.graph[group].text,
        15
      )}"`;
    }
    let membersString = "";
    membersString += `Members: `;
    for (const member of this.members) {
      membersString += `
	-"${this.ensureStringLength(
        this.graph[member].text,
        15
      )}"`;
    }
    let incomingEdgesString = "";
    incomingEdgesString += `Incoming Edges: `;
    for (const edge of this.incomingEdges) {
      incomingEdgesString += `
	-"${this.ensureStringLength(
        this.graph[edge].text,
        15
      )}"`;
    }
    let outgoingEdgesString = "";
    outgoingEdgesString += `Outgoing Edges: `;
    for (const edge of this.outgoingEdges) {
      outgoingEdgesString += `
	-"${this.ensureStringLength(
        this.graph[edge].text,
        15
      )}"`;
    }
    return `[::] Group ${this.id} Text: "${this.text}"
${incomingEdgesString}
${outgoingEdgesString}
${groupsString}
${membersString}
` + super.logDetails();
  }
  checkOverlap() {
    const currentGroupRectangle = this.createRectangle(
      this.canvasData.x,
      this.canvasData.y,
      this.canvasData.width,
      this.canvasData.height
    );
    for (const objectKey in this.graph) {
      const object = this.graph[objectKey];
      if (object instanceof CannoliVertex) {
        if (object === this)
          continue;
        const objectRectangle = this.createRectangle(
          object.canvasData.x,
          object.canvasData.y,
          object.canvasData.width,
          object.canvasData.height
        );
        if (this.overlaps(objectRectangle, currentGroupRectangle)) {
          this.error(
            `This group overlaps with another object. Please ensure objects fully enclose their members.`
          );
          return;
        }
      }
    }
  }
  validateExitingAndReenteringPaths() {
    const visited = /* @__PURE__ */ new Set();
    const dfs = (vertex, hasLeftGroup) => {
      visited.add(vertex);
      for (const edge of vertex.getOutgoingEdges()) {
        const targetVertex = edge.getTarget();
        const isTargetInsideGroup = targetVertex.getGroups().includes(this);
        if (hasLeftGroup && isTargetInsideGroup) {
          this.error(
            `A path leaving this group and re-enters it, this would cause deadlock.`
          );
          return;
        }
        if (!visited.has(targetVertex)) {
          dfs(targetVertex, hasLeftGroup || !isTargetInsideGroup);
        }
      }
    };
    const members = this.getMembers();
    for (const member of members) {
      if (!visited.has(member)) {
        dfs(member, false);
      }
    }
  }
  validate() {
    super.validate();
    this.validateExitingAndReenteringPaths();
    this.checkOverlap();
  }
};
var ForEachGroup = class extends CannoliGroup {
  constructor(forEachData) {
    super(forEachData);
  }
  logDetails() {
    return super.logDetails() + `Type: ForEach
Index: ${this.currentLoop}
`;
  }
  async execute() {
    this.status = "executing" /* Executing */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "executing" /* Executing */ }
    });
    this.dispatchEvent(event);
  }
  dependencyCompleted(dependency) {
    if (this.status === "executing" /* Executing */) {
      if (this.allMembersCompleteOrRejected()) {
        this.completed();
      }
    }
  }
  validate() {
    super.validate();
  }
};
var RepeatGroup = class extends CannoliGroup {
  constructor(groupData) {
    var _a2, _b;
    super(groupData);
    this.currentLoop = (_a2 = groupData.cannoliData.currentLoop) != null ? _a2 : 0;
    this.maxLoops = (_b = groupData.cannoliData.maxLoops) != null ? _b : 1;
  }
  async execute() {
    this.status = "executing" /* Executing */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "executing" /* Executing */ }
    });
    this.dispatchEvent(event);
  }
  resetMembers() {
    for (const member of this.getMembers()) {
      member.reset();
      for (const edge of member.outgoingEdges) {
        const edgeObject = this.graph[edge];
        if (edgeObject.getTarget() !== this) {
          edgeObject.reset();
        }
      }
    }
  }
  membersFinished() {
    if (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      this.currentLoop < this.maxLoops - 1 && this.allEdgeDependenciesComplete()
    ) {
      this.currentLoop++;
      if (!this.run.isMock) {
        setTimeout(() => {
          this.resetMembers();
          this.executeMembers();
        }, 20);
      } else {
        this.resetMembers();
        this.executeMembers();
      }
    } else {
      this.status = "complete" /* Complete */;
      const event = new CustomEvent("update", {
        detail: { obj: this, status: "complete" /* Complete */ }
      });
      this.dispatchEvent(event);
    }
  }
  executeMembers() {
    for (const member of this.getMembers()) {
      member.dependencyCompleted(this);
    }
  }
  reset() {
    super.reset();
    this.currentLoop = 0;
  }
  logDetails() {
    return super.logDetails() + `Type: Repeat
Max Loops: ${this.maxLoops}
`;
  }
  validate() {
    super.validate();
    if (this.maxLoops === null) {
      this.error(
        `Repeat groups loops must have a valid number in their label. Please ensure the label is a positive integer.`
      );
    }
    const listOrCategoryEdges = this.incomingEdges.filter(
      (edge) => this.graph[edge].type === "list" /* List */ || this.graph[edge].type === "category" /* Category */
    );
    if (listOrCategoryEdges.length !== 0) {
      this.error(
        `Repeat groups can't have incoming edges of type list or category.`
      );
    }
    if (this.outgoingEdges.length !== 0) {
      this.error(`Repeat groups can't have any outgoing edges.`);
    }
  }
};

// src/models/edge.ts
var CannoliEdge = class extends CannoliObject {
  constructor(edgeData) {
    super(edgeData);
    this.source = edgeData.fromNode;
    this.target = edgeData.toNode;
    this.crossingInGroups = edgeData.cannoliData.crossingInGroups;
    this.crossingOutGroups = edgeData.cannoliData.crossingOutGroups;
    this.isReflexive = edgeData.cannoliData.isReflexive;
    this.addMessages = edgeData.cannoliData.addMessages;
    this.vaultModifier = edgeData.cannoliData.vaultModifier ? edgeData.cannoliData.vaultModifier : null;
    this.content = edgeData.cannoliData.content ? edgeData.cannoliData.content : null;
    this.messages = edgeData.cannoliData.messages ? edgeData.cannoliData.messages : null;
    if (this.type === "chat" /* Chat */ || this.type === "system-message" /* SystemMessage */ || this.type === "chat-response" /* ChatResponse */ || this.type === "chat-converter" /* ChatConverter */) {
      this.addMessages = true;
    }
  }
  getSource() {
    return this.graph[this.source];
  }
  getTarget() {
    return this.graph[this.target];
  }
  load({
    content,
    request
  }) {
    this.content = content !== null && content !== void 0 ? content : null;
    if (this.addMessages) {
      this.messages = request && request.messages ? request.messages : null;
    }
  }
  async execute() {
    this.completed();
  }
  dependencyCompleted(dependency) {
    if (this.allDependenciesComplete() && this.status === "pending" /* Pending */) {
      this.execute();
    }
  }
  logDetails() {
    var _a2, _b, _c;
    let crossingGroupsString = "";
    crossingGroupsString += `Crossing Out Groups: `;
    for (const group of this.crossingOutGroups) {
      crossingGroupsString += `
	-"${this.ensureStringLength(
        this.graph[group].text,
        15
      )}"`;
    }
    crossingGroupsString += `
Crossing In Groups: `;
    for (const group of this.crossingInGroups) {
      crossingGroupsString += `
	-"${this.ensureStringLength(
        this.graph[group].text,
        15
      )}"`;
    }
    return `--> Edge ${this.id} Text: "${(_a2 = this.text) != null ? _a2 : "undefined string"}"
"${this.ensureStringLength(
      (_b = this.getSource().text) != null ? _b : "undefined string",
      15
    )}--->"${this.ensureStringLength(
      (_c = this.getTarget().text) != null ? _c : "undefined string",
      15
    )}"
${crossingGroupsString}
isReflexive: ${this.isReflexive}
Type: ${this.type}
` + super.logDetails();
  }
  reset() {
    if (!this.isReflexive) {
      super.reset();
    }
  }
};
var ChatConverterEdge = class extends CannoliEdge {
  load({
    content,
    request
  }) {
    const format = this.run.cannoli.settings.chatFormatString;
    const messageString = "";
    let messages = [];
    if (content && format) {
      messages = this.stringToArray(content, format);
    } else {
      throw new Error(
        "Chat converter edge was loaded without a content or messages"
      );
    }
    this.content = messageString;
    this.messages = messages;
  }
  stringToArray(str2, format) {
    const rolePattern = format.replace("{{role}}", "(System|User|Assistant)").replace("{{content}}", "").trim();
    const regex = new RegExp(rolePattern, "g");
    let match;
    let messages = [];
    let lastIndex = 0;
    let firstMatch = true;
    while ((match = regex.exec(str2)) !== null) {
      const [, role] = match;
      if (firstMatch && match.index > 0) {
        messages.push({
          role: "user",
          content: str2.substring(0, match.index).trim()
        });
      }
      firstMatch = false;
      const start = regex.lastIndex;
      let end;
      const nextMatch = regex.exec(str2);
      if (nextMatch) {
        end = nextMatch.index;
      } else {
        end = str2.length;
      }
      regex.lastIndex = start;
      const content = str2.substring(start, end).trim();
      const uncapRole = role.charAt(0).toLowerCase() + role.slice(1);
      messages.push({
        role: uncapRole,
        content
      });
      lastIndex = end;
    }
    if (messages.length === 0) {
      messages.push({
        role: "user",
        content: str2.trim()
      });
      return messages;
    }
    if (lastIndex < str2.length - 1) {
      messages.push({
        role: "user",
        content: str2.substring(lastIndex).trim()
      });
    }
    if (this.text.length > 0) {
      messages = this.limitMessages(messages);
    }
    return messages;
  }
  limitMessages(messages) {
    let isTokenBased = false;
    let originalText = this.text;
    if (originalText.startsWith("#")) {
      isTokenBased = true;
      originalText = originalText.substring(1);
    }
    const limitValue = Number(originalText);
    if (isNaN(limitValue) || limitValue < 0) {
      return messages;
    }
    let outputMessages;
    if (isTokenBased) {
      const maxCharacters = limitValue * 4;
      let totalCharacters = 0;
      let index = 0;
      for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.content) {
          totalCharacters += message.content.length;
        }
        if (totalCharacters > maxCharacters) {
          index = i + 1;
          break;
        }
      }
      outputMessages = messages.slice(index);
    } else {
      outputMessages = messages.slice(-Math.max(limitValue, 1));
    }
    if (outputMessages.length === 0 && messages.length > 0) {
      outputMessages = [messages[messages.length - 1]];
    }
    return outputMessages;
  }
};
var ChatResponseEdge = class extends CannoliEdge {
  constructor() {
    super(...arguments);
    this.beginningOfStream = true;
  }
  load({
    content,
    request
  }) {
    const format = this.run.cannoli.settings.chatFormatString;
    if (!format) {
      throw new Error(
        "Chat response edge was loaded without a format string"
      );
    }
    if (content && typeof content === "string") {
      if (!this.beginningOfStream) {
        if (content === "END OF STREAM") {
          const userTemplate = format.replace("{{role}}", "User").replace("{{content}}", "");
          this.content = "\n\n" + userTemplate;
        } else {
          this.content = content;
        }
      } else {
        const assistantTemplate = format.replace("{{role}}", "Assistant").replace("{{content}}", content);
        this.content = "\n\n" + assistantTemplate;
        this.beginningOfStream = false;
      }
      this.execute();
    }
  }
};
var SystemMessageEdge = class extends CannoliEdge {
  load({
    content,
    request
  }) {
    if (content) {
      this.messages = [
        {
          role: "system",
          content
        }
      ];
    }
  }
};
var LoggingEdge = class extends CannoliEdge {
  load({
    content,
    request
  }) {
    let configString = null;
    let messages = [];
    if (request) {
      configString = this.getConfigString(request);
      messages = request.messages ? request.messages : [];
    } else {
      throw new Error(
        "Logging edge was loaded without a request, this should never happen"
      );
    }
    let logs = "";
    const repeatLoopNumbers = this.getLoopNumbers();
    const loopHeader = this.formatLoopHeader(repeatLoopNumbers);
    const forEachVersionNumbers = this.getForEachVersionNumbers();
    const versionHeader = this.formatVersionHeader(forEachVersionNumbers);
    if (repeatLoopNumbers.length > 0) {
      logs = `${loopHeader}
`;
    }
    if (forEachVersionNumbers.length > 0) {
      logs = `${logs}${versionHeader}
`;
    }
    if (messages !== void 0) {
      logs = `${logs}${this.formatInteractionHeaders(messages)}`;
    }
    if (configString !== null) {
      logs = `${logs}
#### Config
${configString}
`;
    }
    if (this.content !== null) {
      this.content = `${this.content}
${logs}`;
    } else {
      this.content = logs;
    }
  }
  getConfigString(request) {
    let configString = "";
    for (const key in request) {
      if (key !== "messages" && request[key]) {
        configString += `${key}: ${request[key]}
`;
      }
    }
    return configString;
  }
  getLoopNumbers() {
    const repeatLoopNumbers = [];
    this.crossingOutGroups.forEach((group) => {
      const groupObject = this.graph[group];
      if (groupObject instanceof RepeatGroup) {
        repeatLoopNumbers.push(groupObject.currentLoop);
      }
    });
    repeatLoopNumbers.reverse();
    return repeatLoopNumbers;
  }
  getForEachVersionNumbers() {
    const forEachVersionNumbers = [];
    this.crossingOutGroups.forEach((group) => {
      const groupObject = this.graph[group];
      if (groupObject instanceof ForEachGroup) {
        forEachVersionNumbers.push(groupObject.currentLoop);
      }
    });
    forEachVersionNumbers.reverse();
    return forEachVersionNumbers;
  }
  formatInteractionHeaders(messages) {
    let formattedString = "";
    messages.forEach((message) => {
      const role = message.role;
      let content = message.content;
      if (message.function_call) {
        content = `Function Call: **${message.function_call.name}**
Arguments:
\`\`\`json
${message.function_call.arguments}
\`\`\``;
      }
      formattedString += `#### <u>${role.charAt(0).toUpperCase() + role.slice(1)}</u>:
${content}
`;
    });
    return formattedString.trim();
  }
  formatLoopHeader(loopNumbers) {
    let loopString = "# Loop ";
    loopNumbers.forEach((loopNumber) => {
      loopString += `${loopNumber + 1}.`;
    });
    return loopString.slice(0, -1);
  }
  formatVersionHeader(versionNumbers) {
    let versionString = "# Version ";
    versionNumbers.forEach((versionNumber) => {
      versionString += `${versionNumber}.`;
    });
    return versionString.slice(0, -1);
  }
  dependencyCompleted(dependency) {
    if (this.getSource().status === "complete" /* Complete */ && // If all forEach type groups being crossed are complete
    this.crossingOutGroups.every(
      (group) => !(this.graph[group] instanceof ForEachGroup) || this.graph[group].status === "complete" /* Complete */
    )) {
      this.execute();
    }
  }
};

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// src/models/node.ts
var CannoliNode = class extends CannoliVertex {
  constructor(nodeData) {
    super(nodeData);
    this.references = [];
    this.references = nodeData.cannoliData.references || [];
    this.renderFunction = this.buildRenderFunction();
  }
  buildRenderFunction() {
    let textCopy = this.text;
    let index = 0;
    textCopy = textCopy.replace(/\{\{[^{}]+\}\}/g, () => `{{${index++}}}`);
    const renderFunction = async (variables) => {
      textCopy = await this.processEmbeds(textCopy);
      const varMap = new Map(variables.map((v) => [v.name, v.content]));
      return textCopy.replace(/\{\{(\d+)\}\}/g, (match, index2) => {
        const reference = this.references[Number(index2)];
        return varMap.get(reference.name) || "{{invalid}}";
      });
    };
    return renderFunction;
  }
  async processEmbeds(content) {
    const embeddedNotes = content.match(/!\[\[[\s\S]*?\]\]/g);
    if (embeddedNotes) {
      for (const embeddedNote of embeddedNotes) {
        let noteName = embeddedNote.replace("![[", "").replace("]]", "");
        let subpath;
        if (noteName.includes("|")) {
          noteName = noteName.split("|")[0];
        }
        if (noteName.includes("#")) {
          const split = noteName.split("#");
          noteName = split[0];
          subpath = split[1];
        }
        const noteContent = await this.run.getNote({
          name: noteName,
          type: "note" /* Note */,
          shouldExtract: true,
          includeName: true,
          subpath
        });
        if (noteContent) {
          const blockquotedNoteContent = "> " + noteContent.replace(/\n/g, "\n> ");
          content = content.replace(
            embeddedNote,
            blockquotedNoteContent
          );
        }
      }
    }
    return content;
  }
  async getContentFromNote(reference) {
    const note = await this.run.getNote(reference);
    if (note === null) {
      return null;
    }
    return note;
  }
  getContentFromFloatingNode(name) {
    for (const object of Object.values(this.graph)) {
      if (object instanceof FloatingNode && object.getName() === name) {
        return object.getContent();
      }
    }
    return null;
  }
  async processReferences() {
    const variableValues = this.getVariableValues(true);
    const resolvedReferences = await Promise.all(
      this.references.map(async (reference) => {
        let content = "{{invalid reference}}";
        const { name } = reference;
        if ((reference.type === "variable" /* Variable */ || reference.type === "selection" /* Selection */) && !reference.shouldExtract) {
          const variable = variableValues.find(
            (variable2) => variable2.name === reference.name
          );
          if (variable) {
            content = variable.content;
          } else if (reference.name.match(/^#+$/)) {
            const depth = reference.name.length - 1;
            const loopIndex = this.getLoopIndex(depth);
            if (loopIndex !== null) {
              content = loopIndex.toString();
            } else {
              content = `{{${reference.name}}}`;
            }
          } else {
            content = `{{${reference.name}}}`;
          }
        } else if ((reference.type === "variable" /* Variable */ || reference.type === "selection" /* Selection */) && reference.shouldExtract) {
          const variable = variableValues.find(
            (variable2) => variable2.name === reference.name
          );
          if (variable && variable.content) {
            const originalName = reference.name;
            reference.name = variable.content;
            const noteContent = await this.getContentFromNote(
              reference
            );
            reference.name = originalName;
            if (noteContent) {
              content = noteContent;
            } else {
              this.warning(
                `Note "${variable.content}" not found`
              );
              content = `{{@${reference.name}}}`;
            }
          } else {
            content = `{{@${reference.name}}}`;
          }
        } else if (reference.type === "note" /* Note */) {
          if (reference.shouldExtract) {
            const noteContent = await this.getContentFromNote(
              reference
            );
            if (noteContent) {
              content = noteContent;
            } else {
              this.warning(`Note "${reference.name}" not found`);
              content = `{{${reference.name}}}`;
            }
          } else {
            content = reference.name;
          }
        } else if (reference.type === "floating" /* Floating */) {
          if (reference.shouldExtract) {
            const floatingContent = this.getContentFromFloatingNode(
              reference.name
            );
            if (floatingContent) {
              content = floatingContent;
            } else {
              this.warning(`Floating node "${name}" not found`);
              content = `{{[${reference.name}]}}`;
            }
          }
        }
        return { name, content };
      })
    );
    return this.renderFunction(resolvedReferences);
  }
  getLoopIndex(depth) {
    const group = this.graph[this.groups[depth]];
    if (!group) {
      return null;
    }
    if (!(group instanceof CannoliGroup)) {
      return null;
    }
    if (group.type !== "repeat" /* Repeat */ && group.type !== "for-each" /* ForEach */) {
      return null;
    }
    const loopIndex = group.currentLoop + 1;
    return loopIndex;
  }
  getVariableValues(includeGroupEdges) {
    const variableValues = [];
    let availableEdges = this.getAllAvailableProvideEdges();
    if (!includeGroupEdges) {
      availableEdges = availableEdges.filter(
        (edge) => this.incomingEdges.includes(edge.id)
      );
    }
    for (const edge of availableEdges) {
      const edgeObject = this.graph[edge.id];
      if (!(edgeObject instanceof CannoliEdge)) {
        throw new Error(
          `Error on object ${edgeObject.id}: object is not a provide edge.`
        );
      }
      if (!(edgeObject.status === "complete" /* Complete */)) {
        if (!(edgeObject.status === "rejected" /* Rejected */) || !edgeObject.isReflexive || edgeObject.content === null) {
          continue;
        }
      }
      let content;
      if (edgeObject.content === null) {
        continue;
      }
      if (typeof edgeObject.content === "string" && edgeObject.text) {
        content = edgeObject.content;
        const variableValue = {
          name: edgeObject.text,
          content,
          edgeId: edgeObject.id
        };
        variableValues.push(variableValue);
      } else if (typeof edgeObject.content === "object" && !Array.isArray(edgeObject.content)) {
        const multipleVariableValues = [];
        for (const name in edgeObject.content) {
          const variableValue = {
            name,
            content: edgeObject.content[name],
            edgeId: edgeObject.id
          };
          multipleVariableValues.push(variableValue);
        }
        variableValues.push(...multipleVariableValues);
      } else {
        continue;
      }
    }
    if (this.run.currentNote && includeGroupEdges) {
      const currentNoteVariableValue = {
        name: "NOTE",
        content: this.run.currentNote,
        edgeId: ""
      };
      variableValues.push(currentNoteVariableValue);
    }
    if (this.run.selection && includeGroupEdges) {
      const currentSelectionVariableValue = {
        name: "SELECTION",
        content: this.run.selection,
        edgeId: ""
      };
      variableValues.push(currentSelectionVariableValue);
    }
    const resolvedVariableValues = this.resolveVariableConflicts(variableValues);
    return resolvedVariableValues;
  }
  resolveVariableConflicts(variableValues) {
    const finalVariables = [];
    const groupedByName = {};
    for (const variable of variableValues) {
      if (!groupedByName[variable.name]) {
        groupedByName[variable.name] = [];
      }
      groupedByName[variable.name].push(variable);
    }
    for (const name in groupedByName) {
      const variables = groupedByName[name];
      let selectedVariable = variables[0];
      for (const variable of variables) {
        const edgeObject = this.graph[variable.edgeId];
        if (edgeObject instanceof CannoliEdge && edgeObject.isReflexive) {
          selectedVariable = variable;
          break;
        }
      }
      finalVariables.push(selectedVariable);
    }
    return finalVariables;
  }
  loadOutgoingEdges(content, request) {
    for (const edge of this.outgoingEdges) {
      const edgeObject = this.graph[edge];
      if (edgeObject instanceof CannoliEdge && !(edgeObject instanceof ChatResponseEdge)) {
        edgeObject.load({
          content,
          request
        });
      }
    }
  }
  dependencyCompleted(dependency) {
    if (this.allDependenciesComplete() && this.status === "pending" /* Pending */) {
      this.execute();
    }
  }
  getNoteOrFloatingReference() {
    const notePattern = /^{{\[\[([^\]]+)\]\]([\W]*)}}$/;
    const floatingPattern = /^{{\[([^\]]+)\]}}$/;
    const currentNotePattern = /^{{NOTE([\W]*)}}$/;
    const strippedText = this.text.trim();
    let match = notePattern.exec(strippedText);
    if (match) {
      const reference = {
        name: match[1],
        type: "note" /* Note */,
        shouldExtract: false
      };
      const modifiers = match[2];
      if (modifiers) {
        if (modifiers.includes("!#")) {
          reference.includeName = false;
        } else if (modifiers.includes("#")) {
          reference.includeName = true;
        }
        if (modifiers.includes("!$")) {
          reference.includeProperties = false;
        } else if (modifiers.includes("$")) {
          reference.includeProperties = true;
        }
      }
      return reference;
    }
    match = floatingPattern.exec(strippedText);
    if (match) {
      const reference = {
        name: match[1],
        type: "floating" /* Floating */,
        shouldExtract: false
      };
      return reference;
    }
    match = currentNotePattern.exec(strippedText);
    if (match && this.run.currentNote) {
      const reference = {
        name: this.run.currentNote,
        type: "note" /* Note */,
        shouldExtract: false
      };
      const modifiers = match[1];
      if (modifiers) {
        if (modifiers.includes("!#")) {
          reference.includeName = false;
        } else if (modifiers.includes("#")) {
          reference.includeName = true;
        }
        if (modifiers.includes("!$")) {
          reference.includeProperties = false;
        } else if (modifiers.includes("$")) {
          reference.includeProperties = true;
        }
      }
      return reference;
    }
    return null;
  }
  logDetails() {
    let groupsString = "";
    groupsString += `Groups: `;
    for (const group of this.groups) {
      groupsString += `
	-"${this.ensureStringLength(
        this.graph[group].text,
        15
      )}"`;
    }
    let incomingEdgesString = "";
    incomingEdgesString += `Incoming Edges: `;
    for (const edge of this.incomingEdges) {
      incomingEdgesString += `
	-"${this.ensureStringLength(
        this.graph[edge].text,
        15
      )}"`;
    }
    let outgoingEdgesString = "";
    outgoingEdgesString += `Outgoing Edges: `;
    for (const edge of this.outgoingEdges) {
      outgoingEdgesString += `
	-"${this.ensureStringLength(
        this.graph[edge].text,
        15
      )}"`;
    }
    return `[] Node ${this.id} Text: "${this.text}"
${incomingEdgesString}
${outgoingEdgesString}
${groupsString}
` + super.logDetails();
  }
  validate() {
    super.validate();
    if (this.incomingEdges.filter(
      (edge) => this.graph[edge].type === "list" /* List */
    ).length > 1) {
      this.error(`Nodes can only have one incoming list edge.`);
    }
  }
  getSpecialOutgoingEdges() {
    const specialOutgoingEdges = this.getOutgoingEdges().filter((edge) => {
      return edge.type === "field" /* Field */ || edge.type === "choice" /* Choice */ || edge.type === "category" /* Category */ || edge.type === "merge" /* Merge */ || edge.type === "list" /* List */ || edge.type === "variable" /* Variable */;
    });
    return specialOutgoingEdges;
  }
  specialOutgoingEdgesAreHomogeneous() {
    const specialOutgoingEdges = this.getSpecialOutgoingEdges();
    if (specialOutgoingEdges.length === 0) {
      return true;
    }
    const firstEdgeType = specialOutgoingEdges[0].type;
    for (const edge of specialOutgoingEdges) {
      if (edge.type !== firstEdgeType) {
        return false;
      }
    }
    return true;
  }
  getAllAvailableProvideEdges() {
    const availableEdges = [];
    for (const group of this.groups) {
      const groupObject = this.graph[group];
      if (!(groupObject instanceof CannoliVertex)) {
        throw new Error(
          `Error on node ${this.id}: group is not a vertex.`
        );
      }
      const groupIncomingEdges = groupObject.getIncomingEdges();
      availableEdges.push(...groupIncomingEdges);
    }
    const nodeIncomingEdges = this.getIncomingEdges();
    availableEdges.push(...nodeIncomingEdges);
    const filteredEdges = availableEdges.filter(
      (edge) => edge.type !== "logging" /* Logging */ && edge.type !== "write" /* Write */ && edge.type !== "config" /* Config */
    );
    return filteredEdges;
  }
};
var CallNode = class extends CannoliNode {
  getPrependedMessages() {
    const messages = [];
    const availableEdges = this.getAllAvailableProvideEdges();
    const directEdges = availableEdges.filter(
      (edge) => this.incomingEdges.includes(edge.id)
    );
    const indirectEdges = availableEdges.filter(
      (edge) => !this.incomingEdges.includes(edge.id)
    );
    for (const edge of directEdges) {
      const edgeObject = this.graph[edge.id];
      if (!(edgeObject instanceof CannoliEdge)) {
        throw new Error(
          `Error on object ${edgeObject.id}: object is not a provide edge.`
        );
      }
      const edgeMessages = edgeObject.messages;
      if (!edgeMessages) {
        continue;
      }
      if (edgeMessages.length < 1) {
        continue;
      }
      for (const group of edgeObject.crossingInGroups) {
        const indirectEdgesToGroup = indirectEdges.filter(
          (edge2) => edge2.target === group
        );
        const indirectEdgesToAdd = indirectEdgesToGroup.filter(
          (edge2) => this.graph[edge2.id] instanceof CannoliEdge && this.graph[edge2.id].addMessages
        );
        for (const indirectEdge of indirectEdgesToAdd) {
          const indirectEdgeObject = this.graph[indirectEdge.id];
          if (!(indirectEdgeObject instanceof CannoliEdge)) {
            throw new Error(
              `Error on object ${indirectEdgeObject.id}: object is not a provide edge.`
            );
          }
          const indirectEdgeMessages = indirectEdgeObject.messages;
          if (!indirectEdgeMessages) {
            continue;
          }
          if (indirectEdgeMessages.length < 1) {
            continue;
          }
          edgeMessages.length = 0;
          edgeMessages.push(...indirectEdgeMessages);
        }
      }
      if (edgeMessages) {
        if (edge.type === "system-message" /* SystemMessage */) {
          messages.unshift(edgeMessages[0]);
        } else {
          messages.push(...edgeMessages);
        }
      }
    }
    if (messages.length === 0 && this.incomingEdges.filter(
      (edge) => this.cannoliGraph.isEdge(this.graph[edge]) && this.graph[edge].addMessages
    ).length === 0) {
      for (const edge of indirectEdges) {
        const edgeObject = this.graph[edge.id];
        if (!(edgeObject instanceof CannoliEdge)) {
          throw new Error(
            `Error on object ${edgeObject.id}: object is not a provide edge.`
          );
        }
        const edgeMessages = edgeObject.messages;
        if (!edgeMessages) {
          continue;
        }
        if (edgeMessages.length < 1) {
          continue;
        }
        if (edgeMessages) {
          if (edge.type === "system-message" /* SystemMessage */) {
            messages.unshift(edgeMessages[0]);
          } else {
            messages.push(...edgeMessages);
          }
        }
      }
    }
    return messages;
  }
  async getNewMessage(role) {
    const content = await this.processReferences();
    if (!content) {
      return null;
    }
    return {
      role: role || "user",
      content
    };
  }
  findNoteReferencesInMessages(messages) {
    var _a2;
    const references = [];
    const noteRegex = /\[\[(.+?)\]\]/g;
    for (const message of messages) {
      const matches = (_a2 = message.content) == null ? void 0 : _a2.matchAll(noteRegex);
      if (!matches) {
        continue;
      }
      for (const match of matches) {
        references.push(match[1]);
      }
    }
    return references;
  }
  getDefaultConfig() {
    const config = JSON.parse(JSON.stringify(this.run.getDefaultConfig()));
    return config;
  }
  updateConfigWithValue(runConfig, content, setting) {
    const sampleOpenAIConfig = {
      model: "",
      frequency_penalty: void 0,
      presence_penalty: void 0,
      stop: void 0,
      function_call: void 0,
      functions: void 0,
      temperature: void 0,
      top_p: void 0,
      role: "user"
    };
    const keyTypeMap = {
      frequency_penalty: "number",
      presence_penalty: "number",
      temperature: "number",
      top_p: "number"
    };
    const convertValue = (key, value) => {
      const expectedType = keyTypeMap[key];
      return expectedType === "number" ? parseFloat(value) : value;
    };
    const isValidKey = (key) => {
      return key in sampleOpenAIConfig;
    };
    if (typeof content === "string") {
      if (setting && isValidKey(setting)) {
        runConfig[setting] = convertValue(setting, content);
      } else {
        this.error(`"${setting}" is not a valid config setting.`);
      }
    } else if (typeof content === "object") {
      for (const key in content) {
        if (isValidKey(key)) {
          runConfig[key] = convertValue(key, content[key]);
        } else {
          this.error(`"${key}" is not a valid config setting.`);
        }
      }
    }
  }
  processSingleEdge(runConfig, edgeObject) {
    if (typeof edgeObject.content === "string" || typeof edgeObject.content === "object") {
      this.updateConfigWithValue(
        runConfig,
        edgeObject.content,
        edgeObject.text
      );
    } else {
      this.error(`Config edge has invalid content.`);
    }
  }
  processEdges(runConfig, edges) {
    for (const edgeObject of edges) {
      if (!(edgeObject instanceof CannoliEdge)) {
        throw new Error(
          `Error processing config edges: object is not an edge.`
        );
      }
      this.processSingleEdge(runConfig, edgeObject);
    }
  }
  processGroups(runConfig) {
    for (let i = this.groups.length - 1; i >= 0; i--) {
      const group = this.graph[this.groups[i]];
      if (group instanceof CannoliGroup) {
        const configEdges = group.getIncomingEdges().filter((edge) => edge.type === "config" /* Config */);
        this.processEdges(runConfig, configEdges);
      }
    }
  }
  processNodes(runConfig) {
    const configEdges = this.getIncomingEdges().filter(
      (edge) => edge.type === "config" /* Config */
    );
    this.processEdges(runConfig, configEdges);
  }
  getConfig() {
    const runConfig = this.getDefaultConfig();
    this.processGroups(runConfig);
    this.processNodes(runConfig);
    return runConfig;
  }
  async execute() {
    var _a2, _b, _c, _d;
    this.executing();
    const request = await this.createLLMRequest();
    if (request.messages.length === 0) {
      this.error(
        `No messages to send to LLM. Empty call nodes only send the message history they've been passed.`
      );
      return;
    }
    const chatResponseEdges = this.getOutgoingEdges().filter(
      (edge) => edge.type === "chat-response" /* ChatResponse */
    );
    if (chatResponseEdges.length > 0) {
      request.stream = true;
      const stream = await this.run.callLLMStream(
        request
      );
      if (stream instanceof Error) {
        this.error(`Error calling LLM:
${stream.message}`);
        return;
      }
      if (!stream) {
        this.error(`Error calling LLM: no stream returned.`);
        return;
      }
      if (typeof stream === "string") {
        this.loadOutgoingEdges(stream, request);
        this.completed();
        return;
      }
      let messageContent = "";
      for await (const part of stream) {
        if (part instanceof Error) {
          this.error(`Error calling LLM:
${part.message}`);
          return;
        }
        if (!part) {
          this.error(`Error calling LLM: no part returned.`);
          return;
        }
        if (part.choices[0].finish_reason) {
          for (const edge of chatResponseEdges) {
            edge.load({
              content: "END OF STREAM",
              request
            });
          }
          continue;
        }
        messageContent += part.choices[0].delta.content;
        for (const edge of chatResponseEdges) {
          edge.load({
            content: (_a2 = part.choices[0].delta.content) != null ? _a2 : "",
            request
          });
        }
      }
      request.messages.push({
        role: "assistant",
        content: messageContent
      });
      this.loadOutgoingEdges(messageContent, request);
    } else {
      delete request.stream;
      const message = await this.run.callLLM(
        request
      );
      if (message instanceof Error) {
        this.error(`Error calling LLM:
${message.message}`);
        return;
      }
      if (!message) {
        this.error(`Error calling LLM: no message returned.`);
        return;
      }
      request.messages.push(message);
      if ((_b = message.function_call) == null ? void 0 : _b.arguments) {
        if (message.function_call.name === "note_select") {
          const args = JSON.parse(message.function_call.arguments);
          args.note = `[[${args.note}]]`;
          this.loadOutgoingEdges(args.note, request);
        } else {
          this.loadOutgoingEdges((_c = message.content) != null ? _c : "", request);
        }
      } else {
        this.loadOutgoingEdges((_d = message.content) != null ? _d : "", request);
      }
    }
    this.completed();
  }
  async createLLMRequest() {
    const config = this.getConfig();
    const messages = this.getPrependedMessages();
    const newMessage = await this.getNewMessage(config.role);
    delete config.role;
    if (newMessage) {
      messages.push(newMessage);
    }
    const functions = this.getFunctions(messages);
    const function_call = functions && functions.length > 0 ? { name: functions[0].name } : void 0;
    return {
      messages,
      ...config,
      functions: functions && functions.length > 0 ? functions : void 0,
      function_call: function_call ? function_call : void 0
    };
  }
  getFunctions(messages) {
    if (this.getOutgoingEdges().some(
      (edge) => edge.vaultModifier === "note" /* Note */
    )) {
      const noteNames = this.findNoteReferencesInMessages(messages);
      return [this.run.createNoteNameFunction(noteNames)];
    } else {
      return [];
    }
  }
  logDetails() {
    return super.logDetails() + `Type: Call
`;
  }
  validate() {
    super.validate();
  }
};
var FormNode = class extends CallNode {
  getFunctions(messages) {
    const fields = this.getFields();
    const fieldsWithNotes = [];
    const noteEdges = this.getOutgoingEdges().filter(
      (edge) => edge.vaultModifier === "note" /* Note */
    );
    for (const item of fields) {
      if (noteEdges.find((edge) => edge.text === item)) {
        const noteNames = this.findNoteReferencesInMessages(messages);
        fieldsWithNotes.push({ name: item, noteNames });
      } else {
        fieldsWithNotes.push({ name: item });
      }
    }
    const formFunc = this.run.createFormFunction(fieldsWithNotes);
    return [formFunc];
  }
  getFields() {
    const outgoingFieldEdges = this.getOutgoingEdges().filter((edge) => {
      return edge.type === "field" /* Field */;
    });
    const uniqueNames = /* @__PURE__ */ new Set();
    for (const edge of outgoingFieldEdges) {
      const edgeObject = this.graph[edge.id];
      if (!(edgeObject instanceof CannoliEdge)) {
        throw new Error(
          `Error on object ${edgeObject.id}: object is not a field edge.`
        );
      }
      const name = edgeObject.text;
      if (name) {
        uniqueNames.add(name);
      }
    }
    return Array.from(uniqueNames);
  }
  loadOutgoingEdges(content, request) {
    var _a2;
    const messages = request.messages;
    const formFunctionArgs = (_a2 = messages[messages.length - 1].function_call) == null ? void 0 : _a2.arguments;
    if (!formFunctionArgs) {
      this.error(`Form function call has no arguments.`);
      return;
    }
    const fields = JSON.parse(formFunctionArgs);
    for (const edge of this.outgoingEdges) {
      const edgeObject = this.graph[edge];
      if (edgeObject instanceof CannoliEdge) {
        if (edgeObject instanceof CannoliEdge && edgeObject.type === "field" /* Field */) {
          const name = edgeObject.text;
          if (name) {
            const fieldContent = fields[name];
            if (fieldContent) {
              if (edgeObject.vaultModifier === "note" /* Note */) {
                edgeObject.load({
                  content: `[[${fieldContent}]]`,
                  request
                });
              } else {
                edgeObject.load({
                  content: fieldContent,
                  request
                });
              }
            }
          }
        } else {
          edgeObject.load({
            content: formFunctionArgs,
            request
          });
        }
      }
    }
  }
  logDetails() {
    return super.logDetails() + `Subtype: Form
`;
  }
  validate() {
    super.validate();
  }
};
var AccumulateNode = class extends CallNode {
  logDetails() {
    return super.logDetails() + `Subtype: Accumulate
`;
  }
};
var ChooseNode = class extends CallNode {
  getFunctions(messages) {
    const choices = this.getBranchChoices();
    const choiceFunc = this.run.createChoiceFunction(choices);
    return [choiceFunc];
  }
  loadOutgoingEdges(content, request) {
    var _a2;
    const messages = request.messages;
    const choiceFunctionArgs = (_a2 = messages[messages.length - 1].function_call) == null ? void 0 : _a2.arguments;
    if (!choiceFunctionArgs) {
      this.error(`Choice function call has no arguments.`);
      return;
    }
    const parsedVariable = JSON.parse(choiceFunctionArgs);
    this.rejectUnselectedOptions(parsedVariable.choice);
    super.loadOutgoingEdges(choiceFunctionArgs, request);
  }
  rejectUnselectedOptions(choice) {
    for (const edge of this.outgoingEdges) {
      const edgeObject = this.graph[edge];
      if (edgeObject.type === "choice" /* Choice */) {
        const branchEdge = edgeObject;
        if (branchEdge.text !== choice) {
          branchEdge.reject();
        }
      }
    }
  }
  getBranchChoices() {
    const outgoingChoiceEdges = this.getOutgoingEdges().filter((edge) => {
      return edge.type === "choice" /* Choice */;
    });
    const uniqueNames = /* @__PURE__ */ new Set();
    for (const edge of outgoingChoiceEdges) {
      const edgeObject = this.graph[edge.id];
      if (!(edgeObject instanceof CannoliEdge)) {
        throw new Error(
          `Error on object ${edgeObject.id}: object is not a branch edge.`
        );
      }
      const name = edgeObject.text;
      if (name) {
        uniqueNames.add(name);
      }
    }
    return Array.from(uniqueNames);
  }
  logDetails() {
    return super.logDetails() + `Subtype: Choice
`;
  }
  validate() {
    super.validate();
    if (!this.getOutgoingEdges().some(
      (edge) => edge.type === "choice" /* Choice */
    )) {
      this.error(
        `Choice nodes must have at least one outgoing choice edge.`
      );
    }
  }
};
var ContentNode = class extends CannoliNode {
  reset() {
    if (this.type === "standard-content" /* StandardContent */ && this.incomingEdges.length > 0) {
      this.text = "";
    }
    super.reset();
  }
  async execute() {
    this.executing();
    let content = this.getWriteOrLoggingContent();
    if (!content) {
      const variableValues = this.getVariableValues(false);
      if (variableValues.length > 0) {
        content = variableValues[0].content || "";
      } else {
        content = "";
      }
    }
    if (content !== null && content !== void 0 && content !== "") {
      this.text = content;
    } else {
      content = await this.processReferences();
    }
    this.loadOutgoingEdges(content);
    this.completed();
  }
  dependencyCompleted(dependency) {
    if (dependency instanceof LoggingEdge && !dependency.crossingOutGroups.some((group) => {
      const groupObject = this.graph[group];
      if (!(groupObject instanceof CannoliGroup)) {
        throw new Error(
          `Error on object ${groupObject.id}: object is not a group.`
        );
      }
      return groupObject.type === "for-each" /* ForEach */;
    }) || dependency instanceof ChatResponseEdge) {
      this.execute();
    } else if (this.allDependenciesComplete() && this.status === "pending" /* Pending */) {
      this.execute();
    }
  }
  logDetails() {
    return super.logDetails() + `Type: Content
`;
  }
  getWriteOrLoggingContent() {
    const incomingEdges = this.getIncomingEdges();
    if (incomingEdges.filter((edge) => edge.type === "logging" /* Logging */).length > 1) {
      let content = "";
      for (const edge of incomingEdges) {
        const edgeObject = this.graph[edge.id];
        if (edgeObject instanceof LoggingEdge) {
          if (edgeObject.content !== null) {
            content += edgeObject.content;
          }
        }
      }
      return content;
    }
    let filteredEdges = incomingEdges.filter(
      (edge) => (edge.type === "write" /* Write */ || edge.type === "logging" /* Logging */ || edge.type === "chat-response" /* ChatResponse */ || edge.text.length === 0) && this.graph[edge.id].status === "complete" /* Complete */
    );
    filteredEdges = filteredEdges.filter(
      (edge) => edge.vaultModifier !== "folder" /* Folder */ && edge.vaultModifier !== "property" /* Property */
    );
    if (filteredEdges.length === 0) {
      return null;
    }
    const firstEdge = filteredEdges[0];
    const firstEdgeObject = this.graph[firstEdge.id];
    if (firstEdgeObject instanceof CannoliEdge) {
      if (firstEdgeObject.content !== null && typeof firstEdgeObject.content === "string") {
        return firstEdgeObject.content;
      }
    } else {
      throw new Error(
        `Error on object ${firstEdgeObject.id}: object is not an edge.`
      );
    }
    return null;
  }
  validate() {
    super.validate();
  }
};
var ReferenceNode = class extends ContentNode {
  constructor(nodeData) {
    super(nodeData);
    if (this.references.length !== 1) {
      this.error(`Could not find reference.`);
    } else {
      this.reference = this.references[0];
    }
  }
  async execute() {
    this.executing();
    let content = "";
    const writeOrLoggingContent = this.getWriteOrLoggingContent();
    const variableValues = this.getVariableValues(false);
    if (variableValues.length > 0) {
      const variableValueEdges = variableValues.map((variableValue) => {
        return this.graph[variableValue.edgeId];
      });
      const filteredVariableValueEdges = variableValueEdges.filter(
        (variableValueEdge) => {
          return variableValueEdge.text !== this.reference.name && variableValueEdge.vaultModifier !== "folder" /* Folder */ && variableValueEdge.vaultModifier !== "property" /* Property */;
        }
      );
      const filteredVariableValues = variableValues.filter(
        (variableValue) => {
          return filteredVariableValueEdges.some(
            (filteredVariableValueEdge) => {
              return filteredVariableValueEdge.id === variableValue.edgeId;
            }
          );
        }
      );
      if (filteredVariableValues.length > 0) {
        content = filteredVariableValues[0].content;
      } else if (writeOrLoggingContent !== null) {
        content = writeOrLoggingContent;
      }
    } else if (writeOrLoggingContent !== null) {
      content = writeOrLoggingContent;
    }
    const propertyEdges = this.getIncomingEdges().filter(
      (edge) => edge.vaultModifier === "property" /* Property */ && edge.text !== this.reference.name
    );
    if (content) {
      const append = this.getIncomingEdges().some(
        (edge) => edge.type === "chat-response" /* ChatResponse */
      );
      if (this.reference.type === "create-note" /* CreateNote */ || this.reference.type === "variable" /* Variable */) {
        await this.processDynamicReference(content);
      } else {
        await this.editContent(content, append);
        if (propertyEdges.length > 0) {
          for (const edge of propertyEdges) {
            if (edge.content === null || edge.content === void 0 || typeof edge.content !== "string") {
              this.error(`Property arrow has invalid content.`);
              return;
            }
            await this.editProperty(edge.text, edge.content);
          }
        }
      }
      await this.loadOutgoingEdges(content);
    } else {
      if (this.reference.type === "create-note" /* CreateNote */ || this.reference.type === "variable" /* Variable */) {
        await this.processDynamicReference("");
        const fetchedContent = await this.getContent();
        await this.loadOutgoingEdges(fetchedContent);
      } else {
        const fetchedContent = await this.getContent();
        await this.loadOutgoingEdges(fetchedContent);
      }
      if (propertyEdges.length > 0) {
        for (const edge of propertyEdges) {
          if (edge.content === null || edge.content === void 0 || typeof edge.content !== "string") {
            this.error(`Property arrow has invalid content.`);
            return;
          }
          await this.editProperty(edge.text, edge.content);
        }
      }
    }
    this.completed();
  }
  async getContent() {
    if (this.run.isMock) {
      return `Mock content`;
    }
    if (this.reference) {
      if (this.reference.type === "note" /* Note */) {
        const content = await this.getContentFromNote(this.reference);
        if (content !== null && content !== void 0) {
          return content;
        } else {
          this.error(
            `Invalid reference. Could not find note "${this.reference.name}"`
          );
        }
      } else if (this.reference.type === "selection" /* Selection */) {
        const content = this.run.selection;
        if (content !== null && content !== void 0) {
          return content;
        } else {
          this.error(`Invalid reference. Could not find selection.`);
        }
      } else if (this.reference.type === "floating" /* Floating */) {
        const content = this.getContentFromFloatingNode(
          this.reference.name
        );
        if (content) {
          return content;
        } else {
          this.error(
            `Invalid reference. Could not find floating node "${this.reference.name}"`
          );
        }
      } else if (this.reference.type === "variable" /* Variable */ || this.reference.type === "create-note" /* CreateNote */) {
        this.error(`Dynamic reference did not process correctly.`);
      }
    }
    return `Could not find reference.`;
  }
  async processDynamicReference(content) {
    if (this.run.isMock) {
      return;
    }
    const incomingEdges = this.getIncomingEdges();
    const referenceNameEdge = incomingEdges.find(
      (edge) => edge.text === this.reference.name
    );
    if (!referenceNameEdge) {
      this.error(`Could not find arrow containing note name.`);
      return;
    }
    if (referenceNameEdge.content === null || referenceNameEdge.content === void 0 || typeof referenceNameEdge.content !== "string") {
      this.error(`Note name arrow has invalid content.`);
      return;
    }
    const folderEdge = incomingEdges.find(
      (edge) => edge.vaultModifier === "folder" /* Folder */
    );
    let path = "";
    if (folderEdge) {
      if (folderEdge.content === null || folderEdge.content === void 0 || typeof folderEdge.content !== "string") {
        this.error(`Folder arrow has invalid content.`);
        return;
      }
      path = folderEdge.content;
    }
    const propertyEdges = incomingEdges.filter(
      (edge) => edge.vaultModifier === "property" /* Property */ && edge.text !== this.reference.name
    );
    if (this.reference.type === "create-note" /* CreateNote */) {
      let noteName;
      if (propertyEdges.length > 0) {
        let yamlFrontmatter = "---\n";
        for (const edge of propertyEdges) {
          if (edge.content === null || edge.content === void 0 || typeof edge.content !== "string") {
            this.error(`Property arrow has invalid content.`);
            return;
          }
          if (edge.content.startsWith("-")) {
            yamlFrontmatter += `${edge.text}: 
  ${edge.content.replace(/\n/g, "\n  ").trim()}
`;
          } else {
            yamlFrontmatter += `${edge.text}: "${edge.content}"
`;
          }
        }
        yamlFrontmatter += "---\n";
        content = yamlFrontmatter + content;
      }
      try {
        noteName = await this.run.createNoteAtExistingPath(
          referenceNameEdge.content,
          path,
          content
        );
      } catch (e) {
        this.error(`Could not create note: ${e.message}`);
        return;
      }
      if (!noteName) {
        this.error(`"${referenceNameEdge.content}" already exists.`);
      } else {
        this.reference.name = noteName;
        this.reference.type = "note" /* Note */;
      }
    } else {
      this.reference.name = referenceNameEdge.content;
      this.reference.type = "note" /* Note */;
      if (content !== null) {
        await this.editContent(content, false);
      }
      if (propertyEdges.length > 0) {
        for (const edge of propertyEdges) {
          if (edge.content === null || edge.content === void 0 || typeof edge.content !== "string") {
            this.error(`Property arrow has invalid content.`);
            return;
          }
          await this.editProperty(edge.text, edge.content);
        }
      }
    }
  }
  async editContent(newContent, append) {
    if (this.run.isMock) {
      return;
    }
    if (this.reference) {
      if (this.reference.type === "note" /* Note */) {
        const edit = await this.run.editNote(
          this.reference,
          newContent,
          append
        );
        if (edit !== null) {
          return;
        } else {
          this.error(
            `Invalid reference. Could not edit note ${this.reference.name}`
          );
        }
      } else if (this.reference.type === "selection" /* Selection */) {
        this.run.editSelection(newContent);
        return;
      } else if (this.reference.type === "floating" /* Floating */) {
        for (const objectId in this.graph) {
          const object = this.graph[objectId];
          if (object instanceof FloatingNode && object.getName() === this.reference.name) {
            object.editContent(newContent);
            return;
          }
        }
        this.error(
          `Invalid reference. Could not find floating node ${this.reference.name}`
        );
      } else if (this.reference.type === "variable" /* Variable */ || this.reference.type === "create-note" /* CreateNote */) {
        this.error(`Dynamic reference did not process correctly.`);
      }
    }
  }
  async editProperty(propertyName, newContent) {
    if (this.run.isMock) {
      return;
    }
    if (this.reference) {
      if (this.reference.type === "note" /* Note */) {
        const edit = await this.run.editPropertyOfNote(
          this.reference.name,
          propertyName,
          newContent.trim()
        );
        if (edit !== null) {
          return;
        } else {
          this.error(
            `Invalid reference. Could not edit property ${propertyName} of note ${this.reference.name}`
          );
        }
      } else if (this.reference.type === "floating" /* Floating */) {
        for (const objectId in this.graph) {
          const object = this.graph[objectId];
          if (object instanceof FloatingNode && object.getName() === this.reference.name) {
            object.editProperty(propertyName, newContent.trim());
            return;
          }
        }
      } else if (this.reference.type === "variable" /* Variable */ || this.reference.type === "create-note" /* CreateNote */) {
        this.error(`Dynamic reference did not process correctly.`);
      }
    }
  }
  async loadOutgoingEdges(content, request) {
    if (this.reference.type === "floating" /* Floating */) {
      this.loadOutgoingEdgesFloating(content, request);
      return;
    }
    for (const edge of this.outgoingEdges) {
      const edgeObject = this.graph[edge];
      if (!(edgeObject instanceof CannoliEdge)) {
        continue;
      }
      if (edgeObject.vaultModifier === "property" /* Property */) {
        let value;
        if (edgeObject.text.length === 0) {
          value = await this.run.getAllPropertiesOfNote(
            this.reference.name,
            true
          );
        } else {
          value = await this.run.getPropertyOfNote(
            this.reference.name,
            edgeObject.text,
            true
          );
        }
        if (value) {
          edgeObject.load({
            content: value != null ? value : "",
            request
          });
        }
      } else if (edgeObject.vaultModifier === "note" /* Note */) {
        edgeObject.load({
          content: `${this.reference.name}`,
          request
        });
      } else if (edgeObject.vaultModifier === "folder" /* Folder */) {
        const path = await this.run.getNotePath(this.reference.name);
        if (path) {
          edgeObject.load({
            content: path,
            request
          });
        }
      } else if (edgeObject instanceof CannoliEdge && !(edgeObject instanceof ChatResponseEdge)) {
        edgeObject.load({
          content,
          request
        });
      }
    }
  }
  loadOutgoingEdgesFloating(content, request) {
    for (const edge of this.outgoingEdges) {
      const edgeObject = this.graph[edge];
      if (!(edgeObject instanceof CannoliEdge)) {
        continue;
      }
      if (edgeObject.vaultModifier === "note" /* Note */) {
        edgeObject.load({
          content: `${this.reference.name}`,
          request
        });
      } else if (edgeObject.vaultModifier === "property" /* Property */) {
        let propertyContent = "";
        for (const objectId in this.graph) {
          const object = this.graph[objectId];
          if (object instanceof FloatingNode && object.getName() === this.reference.name) {
            propertyContent = object.getProperty(edgeObject.text);
          }
        }
        if (propertyContent) {
          edgeObject.load({
            content: propertyContent,
            request
          });
        }
      } else if (edgeObject instanceof CannoliEdge && !(edgeObject instanceof ChatResponseEdge)) {
        edgeObject.load({
          content,
          request
        });
      }
    }
  }
  logDetails() {
    return super.logDetails() + `Subtype: Reference
`;
  }
  validate() {
    super.validate();
  }
};
var HttpNode = class extends ContentNode {
  logDetails() {
    return super.logDetails() + `Subtype: Http
`;
  }
  async execute() {
    this.executing();
    let content = this.getWriteOrLoggingContent();
    if (!content) {
      const variableValues = this.getVariableValues(false);
      if (variableValues.length > 0) {
        content = {};
        for (const variableValue of variableValues) {
          content[variableValue.name] = variableValue.content || "";
        }
      }
    }
    let template = null;
    for (const objectId in this.graph) {
      const object = this.graph[objectId];
      if (object instanceof FloatingNode && object.getName() === this.text) {
        template = object.text;
      }
    }
    let result;
    if (template) {
      result = await this.run.executeHttpTemplateFromFloatingNode(
        template,
        content
      );
    } else {
      result = await this.run.executeHttpTemplateByName(
        this.text,
        content
      );
    }
    if (result instanceof Error) {
      this.error(result.message);
      return;
    }
    if (typeof result === "string") {
      this.loadOutgoingEdges(result);
    }
    this.completed();
  }
};
var FormatterNode = class extends ContentNode {
  logDetails() {
    return super.logDetails() + `Subtype: Formatter
`;
  }
  async execute() {
    this.executing();
    const content = await this.processReferences();
    const processedContent = content.slice(2, -2);
    this.loadOutgoingEdges(processedContent);
    this.completed();
  }
};
var FloatingNode = class extends CannoliNode {
  constructor(nodeData) {
    super(nodeData);
    this.status = "complete" /* Complete */;
  }
  dependencyCompleted(dependency) {
    return;
  }
  dependencyRejected(dependency) {
    return;
  }
  async execute() {
    this.completed();
  }
  getName() {
    const firstLine = this.text.split("\n")[0].trim();
    return firstLine.substring(1, firstLine.length - 1);
  }
  // Content is everything after the first line
  getContent() {
    const firstLine = this.text.split("\n")[0];
    return this.text.substring(firstLine.length + 1);
  }
  editContent(newContent) {
    const firstLine = this.text.split("\n")[0];
    this.text = `${firstLine}
${newContent}`;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: this.status }
    });
    this.dispatchEvent(event);
  }
  editProperty(propertyName, newContent) {
    const frontmatter = this.getContent().split("---")[1];
    if (!frontmatter) {
      return;
    }
    const parsedFrontmatter = load(
      frontmatter
    );
    if (!parsedFrontmatter) {
      return;
    }
    parsedFrontmatter[propertyName] = newContent;
    const newFrontmatter = dump(parsedFrontmatter);
    const newProps = `---
${newFrontmatter}---
${this.getContent().split("---")[2]}`;
    this.editContent(newProps);
  }
  getProperty(propertyName) {
    if (propertyName.length === 0) {
      return this.getContent().split("---")[1];
    }
    const frontmatter = this.getContent().split("---")[1];
    if (!frontmatter) {
      return "";
    }
    const parsedFrontmatter = load(
      frontmatter
    );
    if (!parsedFrontmatter) {
      return "";
    }
    return parsedFrontmatter[propertyName];
  }
  logDetails() {
    return super.logDetails() + `Type: Floating
Name: ${this.getName()}
Content: ${this.getContent()}
`;
  }
};

// src/models/graph.ts
var CannoliGraph2 = class {
  constructor(cannoliCanvasData) {
    this.graph = {};
    this.cannoliCanvasData = cannoliCanvasData;
    this.hydrateGraph();
    this.addGraphToAll();
    this.setupAllListeners();
  }
  hydrateGraph() {
    var _a2, _b, _c;
    for (const node of this.cannoliCanvasData.nodes) {
      switch ((_a2 = node.cannoliData) == null ? void 0 : _a2.type) {
        case "for-each" /* ForEach */: {
          const forEachGroup = node;
          this.graph[node.id] = new ForEachGroup(forEachGroup);
          break;
        }
        case "repeat" /* Repeat */: {
          const repeatGroup = node;
          this.graph[node.id] = new RepeatGroup(repeatGroup);
          break;
        }
        case "basic" /* Basic */: {
          const basicGroup = node;
          this.graph[node.id] = new CannoliGroup(basicGroup);
          break;
        }
        case "standard-content" /* StandardContent */: {
          const standardContentNode = node;
          this.graph[node.id] = new ContentNode(standardContentNode);
          break;
        }
        case "reference" /* Reference */: {
          const referenceNode = node;
          this.graph[node.id] = new ReferenceNode(referenceNode);
          break;
        }
        case "formatter" /* Formatter */: {
          const formatterNode = node;
          this.graph[node.id] = new FormatterNode(formatterNode);
          break;
        }
        case "http" /* Http */: {
          const httpNode = node;
          this.graph[node.id] = new HttpNode(httpNode);
          break;
        }
        case "standard-call" /* StandardCall */: {
          const standardCallNode = node;
          this.graph[node.id] = new CallNode(standardCallNode);
          break;
        }
        case "choose" /* Choose */: {
          const chooseNode = node;
          this.graph[node.id] = new ChooseNode(chooseNode);
          break;
        }
        case "form" /* Form */: {
          const formNode = node;
          this.graph[node.id] = new FormNode(formNode);
          break;
        }
        case "accumulate" /* Accumulate */: {
          const accumulateNode = node;
          this.graph[node.id] = new AccumulateNode(accumulateNode);
          break;
        }
        case "categorize" /* Categorize */: {
          console.error("Categorize node not implemented");
          break;
        }
        case "select" /* Select */: {
          console.error("Select node not implemented");
          break;
        }
        case "variable" /* Variable */: {
          const variableNode = node;
          this.graph[node.id] = new FloatingNode(variableNode);
          break;
        }
        default: {
          throw new Error(
            `Unknown node type: ${(_b = node.cannoliData) == null ? void 0 : _b.type}`
          );
        }
      }
    }
    for (const edge of this.cannoliCanvasData.edges) {
      switch ((_c = edge.cannoliData) == null ? void 0 : _c.type) {
        case "logging" /* Logging */: {
          const loggingEdge = edge;
          this.graph[edge.id] = new LoggingEdge(loggingEdge);
          break;
        }
        case "system-message" /* SystemMessage */: {
          const systemMessageEdge = edge;
          this.graph[edge.id] = new SystemMessageEdge(
            systemMessageEdge
          );
          break;
        }
        case "chat-converter" /* ChatConverter */: {
          const chatConverterEdge = edge;
          this.graph[edge.id] = new ChatConverterEdge(
            chatConverterEdge
          );
          break;
        }
        case "chat-response" /* ChatResponse */: {
          const chatResponseEdge = edge;
          this.graph[edge.id] = new ChatResponseEdge(
            chatResponseEdge
          );
          break;
        }
        default: {
          const genericEdge = edge;
          this.graph[edge.id] = new CannoliEdge(genericEdge);
          break;
        }
      }
    }
  }
  addGraphToAll() {
    for (const id in this.graph) {
      this.graph[id].setGraph(this.graph, this);
    }
  }
  setupAllListeners() {
    for (const id in this.graph) {
      this.graph[id].setupListeners();
    }
  }
  isEdge(edge) {
    return edge.kind === "edge" /* Edge */;
  }
  isNode(node) {
    return node.kind === "node" /* Node */;
  }
  isGroup(group) {
    return group.kind === "group" /* Group */;
  }
};

// src/factory.ts
var CannoliFactory = class {
  constructor(canvas, activeNote, contentIsColorless) {
    this.vaultModifierMap = {
      "[": "note" /* Note */,
      "/": "folder" /* Folder */,
      ":": "property" /* Property */
    };
    this.nodeColorMap = {
      "0": "call" /* Call */,
      "1": "call" /* Call */,
      "2": "content" /* Content */,
      "3": "call" /* Call */,
      "4": "call" /* Call */,
      "6": "content" /* Content */
    };
    this.edgePrefixMap = {
      "*": "config" /* Config */,
      "?": "choice" /* Choice */,
      "@": "chat-converter" /* ChatConverter */,
      "<": "list" /* List */,
      "=": "field" /* Field */
    };
    this.edgeColorMap = {
      "2": "config" /* Config */,
      "3": "choice" /* Choice */,
      "4": "chat-converter" /* ChatConverter */,
      "5": "list" /* List */,
      "6": "field" /* Field */
    };
    this.addMessagesModifierMap = {
      "|": true,
      "~": false
    };
    this.defaultAddMessagesMap = {
      ["choice" /* Choice */]: true,
      ["chat" /* Chat */]: true,
      ["system-message" /* SystemMessage */]: true,
      ["chat-converter" /* ChatConverter */]: true,
      ["function" /* Function */]: false,
      ["config" /* Config */]: false,
      ["field" /* Field */]: false,
      ["list" /* List */]: false,
      ["merge" /* Merge */]: false,
      ["variable" /* Variable */]: false,
      ["category" /* Category */]: false,
      ["logging" /* Logging */]: false,
      ["write" /* Write */]: false,
      ["chat-response" /* ChatResponse */]: false
    };
    this.groupPrefixMap = {
      "<": "signified-for-each" /* SignifiedForEach */
    };
    this.groupColorMap = {
      "5": "signified-for-each" /* SignifiedForEach */
    };
    this.cannoliData = canvas;
    this.activeNote = activeNote;
    if (contentIsColorless) {
      this.nodeColorMap = {
        "0": "content" /* Content */,
        "1": "call" /* Call */,
        "2": "content" /* Content */,
        "3": "call" /* Call */,
        "4": "call" /* Call */,
        "6": "call" /* Call */
      };
    }
  }
  getCannoliData() {
    this.cannoliData.nodes.forEach((node) => {
      if (node.color === "1") {
        return;
      }
      const kind = this.getVertexKind(node);
      let cannoliData;
      if (kind === "node" /* Node */) {
        node = node;
        cannoliData = this.createNodeData(node);
      } else {
        node = node;
        cannoliData = this.createGroupData(node);
      }
      if (cannoliData) {
        node.cannoliData = cannoliData;
      }
    });
    this.cannoliData.edges.forEach((edge) => {
      if (edge.color === "1") {
        return;
      }
      const cannoliData = this.createEdgeData(edge);
      if (cannoliData) {
        edge.cannoliData = cannoliData;
      }
    });
    let verifiedCannoliData = {
      nodes: this.cannoliData.nodes.filter((node) => !!node.cannoliData),
      edges: this.cannoliData.edges.filter((edge) => !!edge.cannoliData)
    };
    verifiedCannoliData = this.createForEachDuplicates(
      verifiedCannoliData
    );
    for (const node of verifiedCannoliData.nodes) {
      if (node.cannoliData) {
        node.cannoliData.dependencies = this.getVertexDependencies(
          node,
          verifiedCannoliData
        );
      }
    }
    for (const edge of verifiedCannoliData.edges) {
      if (edge.cannoliData) {
        edge.cannoliData.dependencies = this.getEdgeDependencies(edge);
      }
    }
    return verifiedCannoliData;
  }
  createNodeData(node) {
    if (node.cannoliData) {
      return node.cannoliData;
    }
    let universalText;
    if (node.type === "file") {
      node = node;
      const fileName = node.file.split("/").pop();
      universalText = fileName == null ? void 0 : fileName.split(".").shift();
      universalText = `{{[[${universalText}]]}}`;
    } else if (node.type === "link") {
      node = node;
      universalText = node.url;
    } else if (node.type === "text") {
      node = node;
      universalText = node.text;
    }
    const kind = "node" /* Node */;
    const type2 = this.getNodeType(node);
    const text = universalText || "";
    const references = node.type === "text" || node.type === "file" ? this.parseNodeReferences(node) : [];
    const incomingEdges = this.getIncomingEdges(node.id).map(
      (edge) => edge.id
    );
    const outgoingEdges = this.getOutgoingEdges(node.id).map(
      (edge) => edge.id
    );
    const groups = this.getGroupsForVertex(node);
    const dependencies = [];
    const originalObject = null;
    const status = type2 === "variable" /* Variable */ ? "complete" /* Complete */ : "pending" /* Pending */;
    if (!type2) {
      return null;
    }
    return {
      kind,
      type: type2,
      text,
      references,
      incomingEdges,
      outgoingEdges,
      groups,
      dependencies,
      originalObject,
      status
    };
  }
  createGroupData(group) {
    if (group.cannoliData) {
      return group.cannoliData;
    }
    const labelInfo = this.parseGroupLabel(group);
    const kind = "group" /* Group */;
    const type2 = this.getGroupType(group);
    const text = (labelInfo == null ? void 0 : labelInfo.text) || "";
    const incomingEdges = this.getIncomingEdges(group.id).map(
      (edge) => edge.id
    );
    const outgoingEdges = this.getOutgoingEdges(group.id).map(
      (edge) => edge.id
    );
    const groups = this.getGroupsForVertex(group);
    const members = this.getMembersForGroup(group).filter(
      (member) => {
        var _a2;
        return this.getNodeIndicatedType(
          this.cannoliData.nodes.find(
            (node) => node.id === member
          )
        ) !== null || ((_a2 = this.cannoliData.nodes.find((node) => node.id === member)) == null ? void 0 : _a2.type) === "group";
      }
    );
    const dependencies = [];
    const originalObject = group.originalObject;
    const status = type2 === "basic" /* Basic */ ? "complete" /* Complete */ : "pending" /* Pending */;
    const genericProps = {
      kind,
      type: type2,
      text,
      incomingEdges,
      outgoingEdges,
      groups,
      members,
      dependencies,
      originalObject,
      status
    };
    if (type2 === "repeat" /* Repeat */ || type2 === "signified-for-each" /* SignifiedForEach */) {
      return {
        ...genericProps,
        currentLoop: (labelInfo == null ? void 0 : labelInfo.completedNumber) || 0,
        maxLoops: (labelInfo == null ? void 0 : labelInfo.totalNumber) || 0
      };
    } else {
      return genericProps;
    }
  }
  createEdgeData(edge) {
    if (edge.cannoliData) {
      return edge.cannoliData;
    }
    const crossingGroups = this.getCrossingGroups(edge);
    let crossingInGroups = [];
    let crossingOutGroups = [];
    if (crossingGroups) {
      crossingInGroups = crossingGroups.crossingInGroups;
      crossingOutGroups = crossingGroups.crossingOutGroups;
    } else {
      crossingInGroups = [];
      crossingOutGroups = [];
    }
    const labelInfo = this.parseEdgeLabel(edge);
    const kind = "edge" /* Edge */;
    const type2 = this.getEdgeType(edge);
    const text = (labelInfo == null ? void 0 : labelInfo.text) || "";
    const vaultModifier = (labelInfo == null ? void 0 : labelInfo.vaultModifier) || void 0;
    let addMessages = false;
    if (type2) {
      addMessages = this.defaultAddMessagesMap[type2];
    }
    addMessages = (labelInfo == null ? void 0 : labelInfo.addMessages) !== void 0 && (labelInfo == null ? void 0 : labelInfo.addMessages) !== null ? labelInfo.addMessages : addMessages;
    const dependencies = [];
    const originalObject = null;
    const isReflexive = this.isReflexive(edge);
    const status = "pending" /* Pending */;
    if (!type2) {
      return null;
    }
    return {
      kind,
      type: type2,
      text,
      addMessages,
      dependencies,
      originalObject,
      crossingInGroups,
      crossingOutGroups,
      status,
      isReflexive,
      vaultModifier
    };
  }
  createForEachDuplicates(data) {
    for (const group of data.nodes) {
      if (group.cannoliData.kind === "group" /* Group */) {
        if (group.cannoliData.type === "signified-for-each" /* SignifiedForEach */) {
          const castGroup = group;
          if (!castGroup || !castGroup.cannoliData.maxLoops) {
            throw new Error(
              "createForEachDuplicates: castGroup is undefined or castGroup.cannoliData.maxLoops is undefined"
            );
          }
          const incomingEdges = castGroup.cannoliData.incomingEdges.map(
            (edgeId) => data.edges.find(
              (edge) => edge.id === edgeId
            )
          );
          const outgoingEdges = castGroup.cannoliData.outgoingEdges.map(
            (edgeId) => data.edges.find(
              (edge) => edge.id === edgeId
            )
          );
          const outgoingMergeEdge = outgoingEdges.find(
            (edge) => edge.cannoliData.type === "merge" /* Merge */
          );
          const mergeNode = outgoingMergeEdge ? data.nodes.find(
            (node) => node.id === outgoingMergeEdge.toNode
            // eslint-disable-next-line no-mixed-spaces-and-tabs
          ) : null;
          if (mergeNode && mergeNode.cannoliData.kind === "node" /* Node */) {
            const castMergeNode = mergeNode;
            const lines = castMergeNode.cannoliData.text.split("\n");
            const loopLine = lines.find(
              (line) => line.startsWith("{#}")
            );
            if (loopLine) {
              let beforeLoopLine = castMergeNode.cannoliData.text.slice(
                0,
                castMergeNode.cannoliData.text.indexOf(
                  loopLine
                )
              );
              const afterLoopLine = castMergeNode.cannoliData.text.slice(
                castMergeNode.cannoliData.text.indexOf(
                  loopLine
                ) + loopLine.length
              );
              const variables = loopLine.match(/{\w+}/g);
              if (variables) {
                for (
                  let i = 0;
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  i < castGroup.cannoliData.maxLoops;
                  i++
                ) {
                  let newLoopLine = loopLine;
                  newLoopLine = newLoopLine.replace(
                    "{#}",
                    `${i + 1}`
                  );
                  variables.forEach((variable) => {
                    newLoopLine = newLoopLine.replace(
                      variable,
                      `{${variable.slice(1, -1)} ${i + 1}}`
                    );
                  });
                  beforeLoopLine = `${beforeLoopLine}${newLoopLine}

`;
                }
                beforeLoopLine = `${beforeLoopLine}${afterLoopLine.trim()}`;
                castMergeNode.text = beforeLoopLine;
                castMergeNode.cannoliData.text = beforeLoopLine;
              }
            }
            castMergeNode.cannoliData.references = this.parseNodeReferences(castMergeNode);
            data.nodes = data.nodes.map((node) => {
              if (node.id === castMergeNode.id) {
                return castMergeNode;
              } else {
                return node;
              }
            });
          }
          const { crossingInEdges, crossingOutEdges, internalEdges } = this.getCrossingAndInternalEdges(castGroup, data);
          for (let i = 0; i < castGroup.cannoliData.maxLoops; i++) {
            this.createDuplicateGroup(
              group,
              i + 1,
              incomingEdges,
              outgoingEdges,
              crossingInEdges,
              crossingOutEdges,
              internalEdges,
              data
            );
          }
          data.nodes = data.nodes.filter(
            (node) => {
              var _a2;
              return node.id !== group.id && !((_a2 = castGroup.cannoliData) == null ? void 0 : _a2.members.includes(node.id));
            }
          );
          data.edges = data.edges.filter(
            (edge) => !incomingEdges.includes(edge) && !outgoingEdges.includes(edge) && !crossingInEdges.includes(edge) && !crossingOutEdges.includes(edge) && !internalEdges.includes(edge)
          );
        }
      }
    }
    return data;
  }
  createDuplicateGroup(group, index, incomingEdges, outgoingEdges, crossingInEdges, crossingOutEdges, internalEdges, canvas) {
    const duplicateGroup = this.duplicateObject(
      group
    );
    const duplicateMembers = this.duplicateObject(
      group.cannoliData.members.map(
        (memberId) => canvas.nodes.find((node) => node.id === memberId)
      )
    );
    const duplicateIncomingEdges = this.duplicateObject(
      incomingEdges
    );
    const duplicateOutgoingEdges = this.duplicateObject(
      outgoingEdges
    );
    const duplicateCrossingInEdges = this.duplicateObject(
      crossingInEdges
    );
    const duplicateCrossingOutEdges = this.duplicateObject(
      crossingOutEdges
    );
    const duplicateInternalEdges = this.duplicateObject(
      internalEdges
    );
    duplicateGroup.cannoliData.originalObject = group.id;
    duplicateGroup.id = `${duplicateGroup.id}-${index}`;
    duplicateGroup.cannoliData.currentLoop = index;
    duplicateGroup.cannoliData.type = "for-each" /* ForEach */;
    duplicateGroup.cannoliData.groups.forEach((groupId) => {
      const groupData = canvas.nodes.find(
        (node) => node.id === groupId
      );
      if (!groupData) {
        throw new Error("createDuplicateGroup: groupData is undefined");
      }
      groupData.cannoliData.members = groupData.cannoliData.members.map(
        (memberId) => {
          if (memberId === group.id) {
            return duplicateGroup.id;
          } else {
            return memberId;
          }
        }
      );
    });
    const incomingListEdge = canvas.edges.find(
      (edge) => edge.toNode === group.id && edge.cannoliData.type === "list" /* List */
    );
    let accumulatorNode = null;
    duplicateMembers.forEach((member) => {
      var _a2;
      member.cannoliData.originalObject = member.id;
      member.id = `${member.id}-${index}`;
      member.cannoliData.groups = member.cannoliData.groups.map(
        (groupId) => {
          if (groupId === group.id) {
            return duplicateGroup.id;
          } else {
            return groupId;
          }
        }
      );
      member.cannoliData.incomingEdges = [];
      member.cannoliData.outgoingEdges = [];
      if (member.cannoliData.kind === "node" /* Node */) {
        const node = member;
        node.cannoliData.references = (_a2 = node.cannoliData.references) == null ? void 0 : _a2.map(
          (reference) => {
            if (reference.type === "variable" /* Variable */ && reference.name === incomingListEdge.cannoliData.text) {
              reference.name = `${reference.name} ${index}`;
              return reference;
            } else {
              return reference;
            }
          }
        );
      }
    });
    duplicateGroup.cannoliData.members = duplicateMembers.map(
      (member) => member.id
    );
    duplicateGroup.cannoliData.incomingEdges = [];
    duplicateGroup.cannoliData.outgoingEdges = [];
    duplicateIncomingEdges.forEach((edge) => {
      edge.cannoliData.originalObject = edge.id;
      edge.id = `${edge.id}-${index}`;
      edge.toNode = duplicateGroup.id;
      duplicateGroup.cannoliData.incomingEdges.push(edge.id);
      if (edge.cannoliData.type === "list" /* List */) {
        edge.cannoliData.type = "field" /* Field */;
        edge.cannoliData.text = `${edge.cannoliData.text} ${index}`;
      }
      const fromNode = canvas.nodes.find(
        (node) => node.id === edge.fromNode
      );
      if (!fromNode) {
        throw new Error("createDuplicateGroup: fromNode is undefined");
      }
      fromNode.cannoliData.outgoingEdges.push(edge.id);
      fromNode.cannoliData.outgoingEdges = fromNode.cannoliData.outgoingEdges.filter(
        (edgeId) => edgeId !== edge.cannoliData.originalObject
      );
    });
    duplicateOutgoingEdges.forEach((edge) => {
      edge.cannoliData.originalObject = edge.id;
      edge.id = `${edge.id}-${index}`;
      edge.fromNode = duplicateGroup.id;
      duplicateGroup.cannoliData.outgoingEdges.push(edge.id);
      if (edge.cannoliData.type === "merge" /* Merge */) {
        edge.cannoliData.type = "variable" /* Variable */;
        edge.cannoliData.text = `${edge.cannoliData.text} ${index}`;
        accumulatorNode = canvas.nodes.find(
          (node) => node.id === edge.toNode
        );
      }
      const toNode = canvas.nodes.find(
        (node) => node.id === edge.toNode
      );
      if (!toNode) {
        throw new Error("createDuplicateGroup: toNode is undefined");
      }
      toNode.cannoliData.incomingEdges.push(edge.id);
      toNode.cannoliData.incomingEdges = toNode.cannoliData.incomingEdges.filter(
        (edgeId) => edgeId !== edge.cannoliData.originalObject
      );
    });
    duplicateCrossingInEdges.forEach((edge) => {
      edge.cannoliData.originalObject = edge.id;
      edge.id = `${edge.id}-${index}`;
      edge.toNode = `${edge.toNode}-${index}`;
      const toNode = duplicateMembers.find(
        (node) => node.id === edge.toNode
      );
      if (!toNode) {
        throw new Error("createDuplicateGroup: toNode is undefined");
      }
      toNode.cannoliData.incomingEdges.push(edge.id);
      const fromNode = canvas.nodes.find(
        (node) => node.id === edge.fromNode
      );
      if (!fromNode) {
        throw new Error("createDuplicateGroup: fromNode is undefined");
      }
      fromNode.cannoliData.outgoingEdges.push(edge.id);
      fromNode.cannoliData.outgoingEdges = fromNode.cannoliData.outgoingEdges.filter(
        (edgeId) => edgeId !== edge.cannoliData.originalObject
      );
      edge.cannoliData.crossingInGroups = edge.cannoliData.crossingInGroups.map((groupId) => {
        if (groupId === group.id) {
          return duplicateGroup.id;
        } else {
          return groupId;
        }
      });
    });
    duplicateCrossingOutEdges.forEach((edge) => {
      edge.cannoliData.originalObject = edge.id;
      edge.id = `${edge.id}-${index}`;
      edge.fromNode = `${edge.fromNode}-${index}`;
      if (edge.toNode === (accumulatorNode == null ? void 0 : accumulatorNode.id)) {
        edge.cannoliData.text = `${edge.cannoliData.text} ${index}`;
      }
      const fromNode = duplicateMembers.find(
        (node) => node.id === edge.fromNode
      );
      if (!fromNode) {
        throw new Error("createDuplicateGroup: fromNode is undefined");
      }
      fromNode.cannoliData.outgoingEdges.push(edge.id);
      const toNode = canvas.nodes.find(
        (node) => node.id === edge.toNode
      );
      if (!toNode) {
        throw new Error("createDuplicateGroup: toNode is undefined");
      }
      toNode.cannoliData.incomingEdges.push(edge.id);
      toNode.cannoliData.incomingEdges = toNode.cannoliData.incomingEdges.filter(
        (edgeId) => edgeId !== edge.cannoliData.originalObject
      );
      edge.cannoliData.crossingOutGroups = edge.cannoliData.crossingOutGroups.map((groupId) => {
        if (groupId === group.id) {
          return duplicateGroup.id;
        } else {
          return groupId;
        }
      });
    });
    duplicateInternalEdges.forEach((edge) => {
      var _a2, _b;
      edge.fromNode = (_a2 = duplicateMembers.find(
        (member) => member.cannoliData.originalObject === edge.fromNode
      )) == null ? void 0 : _a2.id;
      edge.toNode = (_b = duplicateMembers.find(
        (member) => member.cannoliData.originalObject === edge.toNode
      )) == null ? void 0 : _b.id;
    });
    canvas.nodes.push(duplicateGroup);
    canvas.nodes.push(...duplicateMembers);
    canvas.edges.push(
      ...duplicateIncomingEdges,
      ...duplicateOutgoingEdges,
      ...duplicateCrossingInEdges,
      ...duplicateCrossingOutEdges,
      ...duplicateInternalEdges
    );
  }
  duplicateObject(data) {
    return JSON.parse(JSON.stringify(data));
  }
  getCrossingAndInternalEdges(group, canvas) {
    const crossingInEdges = [];
    const crossingOutEdges = [];
    const internalEdges = [];
    for (const member of group.cannoliData.members) {
      const memberData = canvas.nodes.find(
        (node) => node.id === member
      );
      for (const edgeId of memberData.cannoliData.incomingEdges) {
        const edgeData = canvas.edges.find(
          (edge) => edge.id === edgeId
        );
        if (edgeData.cannoliData.crossingInGroups.includes(group.id)) {
          crossingInEdges.push(edgeData);
        } else {
          internalEdges.push(edgeData);
        }
      }
      for (const edgeId of memberData.cannoliData.outgoingEdges) {
        const edgeData = canvas.edges.find(
          (edge) => edge.id === edgeId
        );
        if (edgeData.cannoliData.crossingOutGroups.includes(group.id)) {
          crossingOutEdges.push(edgeData);
        } else {
          internalEdges.push(edgeData);
        }
      }
    }
    return {
      crossingInEdges,
      crossingOutEdges,
      internalEdges
    };
  }
  getVertexDependencies(vertex, data) {
    var _a2, _b, _c, _d;
    const dependencies = [];
    const incomingEdges = (_a2 = vertex.cannoliData) == null ? void 0 : _a2.incomingEdges;
    if (!incomingEdges) {
      throw new Error(
        "setVertexDependencies: vertex.cannoliData.incomingEdges is undefined"
      );
    }
    incomingEdges.forEach((edge) => {
      const edgeData = data.edges.find(
        (edgeData2) => edgeData2.id === edge
      );
      if (!edgeData) {
        throw new Error("setVertexDependencies: edgeData is undefined");
      }
      if (!edgeData.cannoliData) {
        return;
      }
      dependencies.push(edge);
    });
    const groups = (_b = vertex.cannoliData) == null ? void 0 : _b.groups;
    groups == null ? void 0 : groups.forEach((group) => {
      var _a3;
      const groupData = data.nodes.find(
        (groupData2) => groupData2.id === group
      );
      if (!groupData) {
        throw new Error(
          "setVertexDependencies: groupData is undefined"
        );
      }
      const incomingEdges2 = (_a3 = groupData.cannoliData) == null ? void 0 : _a3.incomingEdges;
      if (!incomingEdges2) {
        throw new Error(
          "setVertexDependencies: group.cannoliData.incomingEdges is undefined"
        );
      }
      incomingEdges2.forEach((edge) => {
        const edgeData = data.edges.find(
          (edgeData2) => edgeData2.id === edge
        );
        if (!edgeData) {
          throw new Error(
            "setVertexDependencies: edgeData is undefined"
          );
        }
        if (!edgeData.cannoliData) {
          return;
        }
        if (edgeData.cannoliData.isReflexive) {
          return;
        } else {
          dependencies.push(edge);
        }
      });
    });
    if (((_c = vertex.cannoliData) == null ? void 0 : _c.kind) === "group" /* Group */) {
      const group = vertex;
      const members = (_d = group.cannoliData) == null ? void 0 : _d.members;
      const existingMembers = members == null ? void 0 : members.filter(
        (member) => data.nodes.some((node) => node.id === member)
      );
      if (existingMembers) {
        dependencies.push(...existingMembers);
      }
    }
    return dependencies;
  }
  getEdgeDependencies(edge) {
    const dependencies = [];
    dependencies.push(edge.fromNode);
    const cannoliData = edge.cannoliData;
    if (!cannoliData) {
      throw new Error("getEdgeDependencies: cannoliData is undefined");
    }
    const crossingOutGroups = cannoliData.crossingOutGroups;
    dependencies.push(...crossingOutGroups);
    return dependencies;
  }
  getNodeType(node) {
    const indicatedType = this.getNodeIndicatedType(node);
    if (indicatedType === "floating" /* Floating */) {
      return "variable" /* Variable */;
    } else if (indicatedType === "content" /* Content */) {
      return this.getContentNodeType(node);
    } else if (indicatedType === "call" /* Call */) {
      const textNode = node;
      return this.getCallNodeType(textNode);
    } else {
      return null;
    }
  }
  getCallNodeType(vertex) {
    const incomingEdges = this.getIncomingEdges(vertex.id);
    const outgoingEdges = this.getOutgoingEdges(vertex.id);
    if (incomingEdges.some(
      (edge) => this.getEdgeType(edge) === "merge" /* Merge */
    )) {
      if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "category" /* Category */
      )) {
        return "categorize" /* Categorize */;
      } else if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "choice" /* Choice */
      )) {
        const choiceEdges = outgoingEdges.filter(
          (edge) => this.getEdgeType(edge) === "choice" /* Choice */
        );
        const choiceLabels = choiceEdges.map(
          (edge) => this.parseEdgeLabel(edge)
        );
        if (choiceLabels.every((label) => label === choiceLabels[0])) {
          return "select" /* Select */;
        } else {
          return "choose" /* Choose */;
        }
      } else if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "field" /* Field */ || this.getEdgeType(edge) === "list" /* List */
      )) {
        return "form" /* Form */;
      } else {
        return "accumulate" /* Accumulate */;
      }
    } else {
      if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "field" /* Field */ || this.getEdgeType(edge) === "list" /* List */
      )) {
        return "form" /* Form */;
      } else if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "choice" /* Choice */
      )) {
        return "choose" /* Choose */;
      } else if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "category" /* Category */
      )) {
        return "categorize" /* Categorize */;
      } else {
        return "standard-call" /* StandardCall */;
      }
    }
  }
  getContentNodeType(node) {
    if (node.type === "file") {
      return "reference" /* Reference */;
    }
    let text = "";
    if (node.type === "text") {
      node = node;
      text = node.text;
    } else {
      node = node;
      text = node.url;
    }
    if (node.color === "2") {
      return "http" /* Http */;
    }
    if (text.startsWith('""') && text.endsWith('""')) {
      return "formatter" /* Formatter */;
    }
    if (text.trim().startsWith("{{") && text.trim().endsWith("}}") && !text.trim().includes("\n") && text.trim().split("{{").length === 2 && text.trim().split("}}").length === 2) {
      return "reference" /* Reference */;
    }
    return "standard-content" /* StandardContent */;
  }
  getVertexKind(vertex) {
    switch (vertex.type) {
      case "file":
        return "node" /* Node */;
      case "link":
        return "node" /* Node */;
      case "text":
        return "node" /* Node */;
      case "group":
        return "group" /* Group */;
    }
  }
  getNodeIndicatedType(vertex) {
    var _a2;
    if (!this.hasEdges(vertex.id)) {
      if (this.isFloatingNode(vertex.id)) {
        return "floating" /* Floating */;
      } else {
        return null;
      }
    }
    switch (vertex.type) {
      case "file":
        return "content" /* Content */;
      case "link":
        return "content" /* Content */;
      case "text":
        if (!vertex.color) {
          vertex.color = "0";
        }
        if (this.nodeColorMap[vertex.color]) {
          return this.nodeColorMap[(_a2 = vertex.color) != null ? _a2 : "0"];
        }
    }
    return null;
  }
  getEdgeType(edge) {
    if (edge.color) {
      if (this.edgeColorMap[edge.color]) {
        if (this.edgeColorMap[edge.color] === "choice" /* Choice */) {
          return this.getChoiceEdgeSubtype(edge);
        } else if (this.edgeColorMap[edge.color] === "field" /* Field */) {
          return "field" /* Field */;
        } else if (this.edgeColorMap[edge.color] === "chat-converter" /* ChatConverter */) {
          const sourceNode = this.getNode(edge.fromNode);
          const targetNode = this.getNode(edge.toNode);
          if (sourceNode && this.getNodeIndicatedType(sourceNode) === "call" /* Call */ && targetNode && this.getNodeIndicatedType(targetNode) === "content" /* Content */) {
            return "chat-response" /* ChatResponse */;
          } else {
            return "chat-converter" /* ChatConverter */;
          }
        } else if (this.edgeColorMap[edge.color] === "config" /* Config */) {
          if (edge.label && edge.label.length > 0) {
            return "config" /* Config */;
          } else {
            return "logging" /* Logging */;
          }
        }
        return this.edgeColorMap[edge.color];
      }
    } else if (edge.label && edge.label.length > 0) {
      if (this.edgePrefixMap[edge.label[0]]) {
        if (this.edgePrefixMap[edge.label[0]] === "choice" /* Choice */) {
          return this.getChoiceEdgeSubtype(edge);
        } else if (this.edgePrefixMap[edge.label[0]] === "field" /* Field */) {
          return this.getKeyEdgeSubtype(edge);
        } else if (this.edgePrefixMap[edge.label[0]] === "config" /* Config */) {
          if (edge.label.length > 1) {
            return "config" /* Config */;
          } else {
            return "logging" /* Logging */;
          }
        }
        return this.edgePrefixMap[edge.label[0]];
      } else {
        return "variable" /* Variable */;
      }
    } else if (!edge.label || edge.label.length === 0) {
      const sourceNode = this.getVertex(edge.fromNode);
      const targetNode = this.getVertex(edge.toNode);
      if (!sourceNode || !targetNode) {
        throw new Error(
          `Edge: ${edge.label} source or target not found`
        );
      }
      if (sourceNode.kind === "group" /* Group */ || targetNode.kind === "group" /* Group */) {
        return "chat" /* Chat */;
      }
      const sourceIndicatedType = this.getNodeIndicatedType(
        sourceNode
      );
      const targetIndicatedType = this.getNodeIndicatedType(
        targetNode
      );
      if (sourceIndicatedType === "content" /* Content */) {
        if (targetIndicatedType === "content" /* Content */) {
          return "write" /* Write */;
        } else {
          return "system-message" /* SystemMessage */;
        }
      } else {
        if (targetIndicatedType === "content" /* Content */) {
          return "write" /* Write */;
        } else {
          return "chat" /* Chat */;
        }
      }
    }
    return null;
  }
  getChoiceEdgeSubtype(edge) {
    const targetGroup = this.getGroup(edge.toNode);
    if (targetGroup) {
      if (this.getGroupType(targetGroup) === "signified-for-each" /* SignifiedForEach */) {
        return "category" /* Category */;
      } else {
        return "choice" /* Choice */;
      }
    } else {
      return "choice" /* Choice */;
    }
  }
  getKeyEdgeSubtype(edge) {
    const sourceGroup = this.getGroup(edge.fromNode);
    const targetGroup = this.getGroup(edge.toNode);
    if (sourceGroup && (this.getGroupType(sourceGroup) === "signified-for-each" /* SignifiedForEach */ || this.getGroupType(sourceGroup) === "signified-for-each" /* SignifiedForEach */)) {
      return "merge" /* Merge */;
    } else if (targetGroup && this.getGroupType(targetGroup) === "signified-for-each" /* SignifiedForEach */) {
      return "list" /* List */;
    }
    return "field" /* Field */;
  }
  getGroupType(group) {
    if (group.color) {
      if (this.groupColorMap[group.color]) {
        return this.groupColorMap[group.color];
      }
    }
    if (group.label) {
      if (this.groupPrefixMap[group.label[0]]) {
        return this.groupPrefixMap[group.label[0]];
      }
      const labelInfo = this.parseGroupLabel(group);
      if (!labelInfo) {
        return "basic" /* Basic */;
      }
      if (labelInfo.isLoop) {
        return "repeat" /* Repeat */;
      } else {
        return "basic" /* Basic */;
      }
    }
    return "basic" /* Basic */;
  }
  getEdge(id) {
    return this.cannoliData.edges.find((edge) => edge.id === id);
  }
  getVertex(id) {
    return this.cannoliData.nodes.find((node) => node.id === id);
  }
  getNode(id) {
    const node = this.cannoliData.nodes.find((node2) => node2.id === id);
    if ((node == null ? void 0 : node.type) === "file" || (node == null ? void 0 : node.type) === "text" || (node == null ? void 0 : node.type) === "link") {
      return node;
    } else {
      return void 0;
    }
  }
  getGroup(id) {
    const group = this.cannoliData.nodes.find((group2) => group2.id === id);
    if ((group == null ? void 0 : group.type) === "group") {
      return group;
    }
  }
  parseEdgeLabel(edge) {
    if (!edge.label) {
      return null;
    }
    let text = edge.label;
    let vaultModifier = null;
    let addMessages = null;
    if (this.vaultModifierMap[edge.label[0]]) {
      vaultModifier = this.vaultModifierMap[edge.label[0]];
      text = text.slice(1);
    } else if (this.vaultModifierMap[edge.label.slice(0, 2)]) {
      vaultModifier = this.vaultModifierMap[edge.label.slice(0, 2)];
      text = text.slice(2);
    }
    if (this.addMessagesModifierMap[edge.label[edge.label.length - 1]] !== void 0) {
      addMessages = this.addMessagesModifierMap[edge.label[edge.label.length - 1]];
      text = text.slice(0, -1);
    }
    return {
      text,
      vaultModifier,
      addMessages
    };
  }
  parseGroupLabel(group) {
    let isLoop = false;
    let text = group.label;
    let completedNumber = null;
    let totalNumber = null;
    if (!text) {
      return null;
    }
    if (this.groupPrefixMap[text[0]]) {
      text = text.slice(1);
    }
    if (text.includes("/")) {
      const splitText = text.split("/");
      if (Number.isInteger(+splitText[0]) && Number.isInteger(+splitText[1])) {
        isLoop = true;
        completedNumber = +splitText[0];
        totalNumber = +splitText[1];
      }
    } else if (Number.isInteger(+text)) {
      isLoop = true;
      completedNumber = 0;
      totalNumber = +text;
    }
    return {
      isLoop,
      text,
      completedNumber,
      totalNumber
    };
  }
  parseNodeReferences(node) {
    const unifiedPattern = /{{(.*?)}}/g;
    const references = [];
    const textCopy = node.text;
    let match;
    while ((match = unifiedPattern.exec(textCopy)) !== null) {
      const content = match[1];
      const reference = {
        name: "",
        type: "variable" /* Variable */,
        // default type
        shouldExtract: false
      };
      let innerMatch;
      if (innerMatch = /^NOTE([\W]*)$/.exec(content)) {
        reference.type = "note" /* Note */;
        reference.shouldExtract = false;
        reference.name = this.activeNote;
        this.handleModifiers(reference, innerMatch[1]);
      } else if (innerMatch = /^SELECTION([\W]*)$/.exec(content)) {
        reference.type = "selection" /* Selection */;
        reference.shouldExtract = false;
        reference.name = "SELECTION";
        this.handleModifiers(reference, innerMatch[1]);
      } else if (innerMatch = /^\[\[(.*?)\]\]([\W]*)$/.exec(content)) {
        reference.type = "note" /* Note */;
        reference.shouldExtract = true;
        reference.name = innerMatch[1];
        this.handleModifiers(reference, innerMatch[2]);
      } else if (innerMatch = /^\[(.*?)\]$/.exec(content)) {
        reference.type = "floating" /* Floating */;
        reference.shouldExtract = true;
        reference.name = innerMatch[1];
      } else if (innerMatch = /^@(.*?)([\W]*)$/.exec(content)) {
        reference.type = "variable" /* Variable */;
        reference.shouldExtract = true;
        reference.name = innerMatch[1];
        this.handleModifiers(reference, innerMatch[2]);
      } else if (innerMatch = /^\+@(.*?)([\W]*)$/.exec(content)) {
        reference.type = "create-note" /* CreateNote */;
        reference.shouldExtract = true;
        reference.name = innerMatch[1];
        this.handleModifiers(reference, innerMatch[2]);
      } else {
        reference.name = content;
      }
      references.push(reference);
    }
    return references;
  }
  handleModifiers(reference, modifiers) {
    if (modifiers.includes("!#")) {
      reference.includeName = false;
    } else if (modifiers.includes("#")) {
      reference.includeName = true;
    }
    if (modifiers.includes("!^")) {
      reference.includeProperties = false;
    } else if (modifiers.includes("^")) {
      reference.includeProperties = true;
    }
  }
  getIncomingEdges(id) {
    return this.cannoliData.edges.filter(
      (edge) => edge.toNode === id && this.isValidEdge(edge)
    );
  }
  getOutgoingEdges(id) {
    return this.cannoliData.edges.filter(
      (edge) => edge.fromNode === id && this.isValidEdge(edge)
    );
  }
  hasEdges(id) {
    if (this.getIncomingEdges(id).length > 0 || this.getOutgoingEdges(id).length > 0) {
      return true;
    } else {
      return false;
    }
  }
  isValidEdge(edge) {
    if (edge.fromEnd === "none" && edge.toEnd === "none") {
      return false;
    } else if (edge.color === "1") {
      return false;
    } else {
      return true;
    }
  }
  isFloatingNode(id) {
    var _a2;
    const node = this.getNode(id);
    const firstLine = (_a2 = node == null ? void 0 : node.text) == null ? void 0 : _a2.split("\n")[0];
    if ((firstLine == null ? void 0 : firstLine.startsWith("[")) && (firstLine == null ? void 0 : firstLine.endsWith("]"))) {
      return true;
    } else {
      return false;
    }
  }
  createRectangle(x, y, width, height) {
    return {
      x,
      y,
      width,
      height,
      x_right: x + width,
      y_bottom: y + height
    };
  }
  encloses(a, b) {
    return a.x <= b.x && a.y <= b.y && a.x_right >= b.x_right && a.y_bottom >= b.y_bottom;
  }
  overlaps(a, b) {
    const horizontalOverlap = a.x < b.x_right && a.x_right > b.x;
    const verticalOverlap = a.y < b.y_bottom && a.y_bottom > b.y;
    const overlap = horizontalOverlap && verticalOverlap;
    return overlap && !this.encloses(a, b) && !this.encloses(b, a);
  }
  getGroupsForVertex(vertex) {
    const groups = [];
    const currentVertexRectangle = this.createRectangle(
      vertex.x,
      vertex.y,
      vertex.width,
      vertex.height
    );
    const allGroups = this.cannoliData.nodes.filter(
      (node) => this.getVertexKind(node) === "group" /* Group */ && node.id !== vertex.id
    );
    for (const group of allGroups) {
      const groupRectangle = this.createRectangle(
        group.x,
        group.y,
        group.width,
        group.height
      );
      if (this.encloses(groupRectangle, currentVertexRectangle)) {
        groups.push(group);
      }
    }
    groups.sort((a, b) => {
      const aArea = a.width * a.height;
      const bArea = b.width * b.height;
      return aArea - bArea;
    });
    return groups.map((group) => group.id);
  }
  getMembersForGroup(group) {
    const members = [];
    const currentGroupRectangle = this.createRectangle(
      group.x,
      group.y,
      group.width,
      group.height
    );
    for (const vertex of this.cannoliData.nodes) {
      if (vertex.id === group.id) {
        continue;
      }
      const vertexRectangle = this.createRectangle(
        vertex.x,
        vertex.y,
        vertex.width,
        vertex.height
      );
      if (this.encloses(currentGroupRectangle, vertexRectangle)) {
        members.push(vertex.id);
      }
    }
    return members;
  }
  getCrossingGroups(edge) {
    const source = this.getVertex(edge.fromNode);
    const target = this.getVertex(edge.toNode);
    if (!source || !target) {
      throw new Error("Source or target vertex is null");
    }
    if (!source.cannoliData || !target.cannoliData) {
      return null;
    }
    let crossingOutGroups = [];
    let crossingInGroups = [];
    const sourceGroups = source.cannoliData.groups.map(
      (groupId) => this.getVertex(groupId)
    );
    const targetGroups = target.cannoliData.groups.map(
      (groupId) => this.getVertex(groupId)
    );
    const sharedGroup = sourceGroups.find(
      (group) => targetGroups.includes(group)
    );
    if (sharedGroup === void 0) {
      crossingOutGroups = [...sourceGroups];
      crossingInGroups = [...targetGroups].reverse();
    } else {
      const sourceIndex = sourceGroups.indexOf(sharedGroup);
      crossingOutGroups = sourceGroups.slice(0, sourceIndex);
      const targetIndex = targetGroups.indexOf(sharedGroup);
      const tempCrossingInGroups = targetGroups.slice(0, targetIndex);
      crossingInGroups = tempCrossingInGroups.reverse();
    }
    const sourceAsGroup = this.getGroup(source.id);
    if (sourceAsGroup) {
      if (targetGroups.includes(sourceAsGroup)) {
        crossingInGroups.shift();
      }
    }
    const targetAsGroup = this.getGroup(target.id);
    if (targetAsGroup) {
      if (sourceGroups.includes(targetAsGroup)) {
        crossingOutGroups.pop();
      }
    }
    return {
      crossingOutGroups: crossingOutGroups.map((group) => group.id),
      crossingInGroups: crossingInGroups.map((group) => group.id)
    };
  }
  isReflexive(edge) {
    const source = this.getVertex(edge.fromNode);
    const target = this.getVertex(edge.toNode);
    if (!source || !target) {
      throw new Error("Source or target vertex is null");
    }
    if (!source.cannoliData || !target.cannoliData) {
      return true;
    }
    if (target.cannoliData.groups.includes(source.id)) {
      return true;
    }
    if (source.cannoliData.groups.includes(target.id)) {
      return true;
    }
    return false;
  }
};

// src/run.ts
var import_obsidian = require("obsidian");

// node_modules/yocto-queue/index.js
var Node = class {
  constructor(value) {
    __publicField(this, "value");
    __publicField(this, "next");
    this.value = value;
  }
};
var _head, _tail, _size;
var Queue = class {
  constructor() {
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _size, void 0);
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    return current.value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();

// node_modules/p-limit/index.js
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      queue.dequeue()();
    }
  };
  const run = async (fn, resolve, args) => {
    activeCount++;
    const result = (async () => fn(...args))();
    resolve(result);
    try {
      await result;
    } catch (e) {
    }
    next();
  };
  const enqueue = (fn, resolve, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve, args));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve) => {
    enqueue(fn, resolve, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
}

// src/run.ts
var Run = class {
  constructor({
    graph,
    onFinish,
    isMock,
    canvas,
    openai,
    openAiConfig,
    cannoli
  }) {
    this.graph = {};
    this.isStopped = false;
    this.currentNote = null;
    this.selection = null;
    this.modelInfo = {
      "gpt-4-1106-preview": {
        name: "gpt-4-1106-preview",
        promptTokenPrice: 0.01 / 1e3,
        // $0.01 per 1K tokens
        completionTokenPrice: 0.03 / 1e3
        // $0.03 per 1K tokens
      },
      "gpt-4-1106-vision-preview": {
        name: "gpt-4-1106-vision-preview",
        promptTokenPrice: 0.01 / 1e3,
        // $0.01 per 1K tokens
        completionTokenPrice: 0.03 / 1e3
        // $0.03 per 1K tokens
      },
      "gpt-4": {
        name: "gpt-4",
        promptTokenPrice: 0.03 / 1e3,
        // $0.03 per 1K tokens
        completionTokenPrice: 0.06 / 1e3
        // $0.06 per 1K tokens
      },
      "gpt-4-32k": {
        name: "gpt-4-32k",
        promptTokenPrice: 0.06 / 1e3,
        // $0.06 per 1K tokens
        completionTokenPrice: 0.12 / 1e3
        // $0.12 per 1K tokens
      },
      "gpt-3.5-turbo": {
        name: "gpt-3.5-turbo",
        promptTokenPrice: 1e-3 / 1e3,
        // $0.0010 per 1K tokens
        completionTokenPrice: 2e-3 / 1e3
        // $0.0020 per 1K tokens
      },
      "gpt-3.5-turbo-1106": {
        name: "gpt-3.5-turbo-1106",
        promptTokenPrice: 1e-3 / 1e3,
        // $0.0010 per 1K tokens
        completionTokenPrice: 2e-3 / 1e3
        // $0.0020 per 1K tokens
      },
      "gpt-3.5-turbo-instruct": {
        name: "gpt-3.5-turbo-instruct",
        promptTokenPrice: 15e-4 / 1e3,
        // $0.0015 per 1K tokens
        completionTokenPrice: 2e-3 / 1e3
        // $0.0020 per 1K tokens
      }
    };
    this.openaiConfig = {
      model: "gpt-3.5-turbo",
      frequency_penalty: void 0,
      presence_penalty: void 0,
      stop: void 0,
      function_call: void 0,
      functions: void 0,
      temperature: void 0,
      top_p: void 0,
      role: "user"
    };
    this.parseBodyTemplate = (template, body) => {
      const variablesInTemplate = (template.match(/\{\{.*?\}\}/g) || []).map(
        (v) => v.slice(2, -2)
      );
      if (variablesInTemplate.length === 1) {
        let valueToReplace;
        if (typeof body === "string") {
          valueToReplace = body;
        } else if (Object.keys(body).length === 1) {
          valueToReplace = Object.values(body)[0];
        } else {
          throw new Error(
            `Expected only one variable in the template, but found multiple values. This node expects the variable:
  - ${variablesInTemplate[0]}

Write to this node using a single variable arrow or a write arrow.`
          );
        }
        return template.replace(
          new RegExp(`{{${variablesInTemplate[0]}}}`, "g"),
          valueToReplace.replace(/\n/g, "\\n").replace(/"/g, '\\"')
        );
      }
      let parsedTemplate = template;
      if (typeof body === "object") {
        for (const variable of variablesInTemplate) {
          if (!(variable in body)) {
            throw new Error(
              `Missing value for variable "${variable}" in available arrows. This template requires the following variables:
${variablesInTemplate.map((v) => `  - ${v}`).join("\n")}`
            );
          }
          parsedTemplate = parsedTemplate.replace(
            new RegExp(`{{${variable}}}`, "g"),
            body[variable].replace(/\n/g, "\\n").replace(/"/g, '\\"')
          );
        }
        for (const key in body) {
          if (!variablesInTemplate.includes(key)) {
            throw new Error(
              `Extra variable "${key}" in available arrows. This template requires the following variables:
${variablesInTemplate.map((v) => `  - ${v}`).join("\n")}`
            );
          }
        }
      } else {
        throw new Error(
          `This action node expected multiple variables, but only found one. This node expects the following variables:
${variablesInTemplate.map((v) => `  - ${v}`).join("\n")}`
        );
      }
      return parsedTemplate;
    };
    var _a2, _b, _c, _d, _e;
    this.graph = graph;
    this.onFinish = onFinish != null ? onFinish : (stoppage) => {
    };
    this.isMock = isMock != null ? isMock : false;
    this.cannoli = cannoli;
    this.canvas = canvas != null ? canvas : null;
    this.openai = openai != null ? openai : null;
    this.usage = {};
    this.llmLimit = pLimit(this.cannoli.settings.pLimit);
    this.currentNote = `[[${(_a2 = this.cannoli.app.workspace.getActiveFile()) == null ? void 0 : _a2.basename}]]`;
    this.selection = ((_c = (_b = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _b.editor) == null ? void 0 : _c.getSelection()) ? (_e = (_d = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _d.editor) == null ? void 0 : _e.getSelection() : null;
    this.openaiConfig = openAiConfig ? openAiConfig : this.openaiConfig;
    for (const object of Object.values(this.graph)) {
      object.setRun(this);
    }
  }
  async start() {
    this.setupListeners();
    this.reset();
    this.validate();
    if (this.canvas && this.isMock) {
      await this.canvas.enqueueRemoveAllErrorNodes();
    }
    for (const object of Object.values(this.graph)) {
      if (object.dependencies.length === 0) {
        object.execute();
      }
    }
  }
  error(message) {
    this.isStopped = true;
    this.onFinish({
      reason: "error",
      usage: this.calculateAllLLMCosts(),
      totalCost: this.getTotalCost(),
      message
    });
    throw new Error(message);
  }
  stop() {
    this.isStopped = true;
    this.onFinish({
      reason: "user",
      usage: this.calculateAllLLMCosts(),
      totalCost: this.getTotalCost()
    });
  }
  reset() {
    this.isStopped = false;
    for (const object of Object.values(this.graph)) {
      object.reset();
    }
  }
  validate() {
    for (const object of Object.values(this.graph)) {
      object.validate();
    }
    if (!this.isDAG(this.graph)) {
      for (const object of Object.values(this.graph)) {
        if (object instanceof CannoliVertex)
          object.error(
            "Cycle detected in graph. Please make sure the graph is a DAG.\n(exception: edges between groups and their members)"
          );
      }
    }
  }
  setupListeners() {
    for (const object of Object.values(this.graph)) {
      object.addEventListener("update", (event) => {
        this.objectUpdated(
          event.detail.obj,
          event.detail.status,
          event.detail.message
        );
      });
    }
  }
  getDefaultConfig() {
    return this.openaiConfig;
  }
  objectUpdated(object, status, message) {
    switch (status) {
      case "complete" /* Complete */: {
        this.objectCompleted(object);
        break;
      }
      case "rejected" /* Rejected */: {
        this.objectRejected(object);
        break;
      }
      case "executing" /* Executing */: {
        this.objectExecuting(object);
        break;
      }
      case "pending" /* Pending */: {
        this.objectPending(object);
        break;
      }
      case "error" /* Error */: {
        this.objectError(object, message);
        break;
      }
      case "warning" /* Warning */: {
        this.objectWarning(object, message);
        break;
      }
      default: {
        throw new Error(`Unknown status: ${status}`);
      }
    }
  }
  objectCompleted(object) {
    if (!this.isMock && this.canvas && object.originalObject === null) {
      if (object instanceof CallNode) {
        this.canvas.enqueueChangeNodeColor(object.id, "4");
      } else if (object instanceof ContentNode || object instanceof FloatingNode) {
        this.canvas.enqueueChangeNodeText(object.id, object.text);
      }
    }
    if (this.allObjectsFinished() && !this.isStopped) {
      this.isStopped = true;
      this.onFinish({
        reason: "complete",
        usage: this.calculateAllLLMCosts(),
        totalCost: this.getTotalCost()
      });
    }
  }
  objectRejected(object) {
    if (this.allObjectsFinished() && !this.isStopped) {
      this.isStopped = true;
      this.onFinish({
        reason: "complete",
        usage: this.calculateAllLLMCosts(),
        totalCost: this.getTotalCost()
      });
    }
  }
  objectExecuting(object) {
    if (!this.isMock && this.canvas && object instanceof CallNode && object.originalObject === null) {
      this.canvas.enqueueChangeNodeColor(object.id, "3");
    }
  }
  objectPending(object) {
    if (this.canvas && object instanceof CallNode) {
      if (this.cannoli.settings.contentIsColorless) {
        this.canvas.enqueueChangeNodeColor(object.id, "6");
      } else {
        this.canvas.enqueueChangeNodeColor(object.id, "0");
      }
    } else if (this.canvas && object instanceof ContentNode && object.text === "") {
      this.canvas.enqueueChangeNodeText(object.id, "");
    }
  }
  objectError(object, message) {
    if (this.canvas && object instanceof CannoliVertex) {
      this.canvas.enqueueAddErrorNode(
        object.id,
        message != null ? message : "Unknown error"
      );
    }
    this.error(message != null ? message : "Unknown error");
  }
  objectWarning(object, message) {
    if (this.canvas && object instanceof CannoliVertex) {
      this.canvas.enqueueAddWarningNode(
        object.id,
        message != null ? message : "Unknown warning"
      );
    }
  }
  allObjectsFinished() {
    for (const object of Object.values(this.graph)) {
      if (object.status !== "complete" /* Complete */ && object.status !== "rejected" /* Rejected */) {
        return false;
      }
    }
    return true;
  }
  isDAG(objects) {
    const states = /* @__PURE__ */ new Map();
    function visit(obj) {
      if (states.get(obj) === 1 /* VISITING */) {
        return false;
      }
      if (states.get(obj) === 2 /* VISITED */) {
        return true;
      }
      states.set(obj, 1 /* VISITING */);
      for (const dependency of obj.getAllDependencies()) {
        if (!visit(dependency)) {
          return false;
        }
      }
      states.set(obj, 2 /* VISITED */);
      return true;
    }
    for (const obj of Object.values(objects)) {
      if (states.get(obj) !== 2 /* VISITED */) {
        if (!visit(obj)) {
          return false;
        }
      }
    }
    return true;
  }
  async callLLM(request, verbose) {
    return this.llmLimit(
      async () => {
        if (this.isMock || !this.openai) {
          return this.createMockFunctionResponse(request);
        }
        try {
          const response = await this.openai.chat.completions.create(
            request
          );
          if (verbose) {
            console.log(
              "Input Messages:\n" + JSON.stringify(request.messages, null, 2) + "\n\nResponse Message:\n" + JSON.stringify(
                response.choices[0].message,
                null,
                2
              )
            );
          }
          if (response.usage) {
            const model = this.modelInfo[request.model];
            if (!this.usage[model.name]) {
              this.usage[model.name] = {
                model,
                modelUsage: {
                  promptTokens: 0,
                  completionTokens: 0,
                  apiCalls: 0,
                  totalCost: 0
                }
              };
            }
            this.usage[model.name].modelUsage.promptTokens += response.usage.prompt_tokens;
            this.usage[model.name].modelUsage.completionTokens += response.usage.completion_tokens;
            this.usage[model.name].modelUsage.apiCalls += 1;
          }
          return response.choices[0].message ? response.choices[0].message : Error("No message returned");
        } catch (e) {
          return e;
        }
      }
    );
  }
  async callLLMStream(request) {
    if (this.isMock || !this.openai) {
      return "Mock response";
    }
    try {
      const response = await this.openai.chat.completions.create(request);
      return response ? response : Error("No message returned");
    } catch (e) {
      return e;
    }
  }
  createMockFunctionResponse(request) {
    var _a2, _b, _c;
    let textMessages = "";
    for (const message of request.messages) {
      if (message.function_call) {
        textMessages += `${message.role}: ${message.content} ${message.function_call} `;
      } else {
        textMessages += `${message.role}: ${message.content} `;
      }
    }
    const promptTokens = textMessages.length / 4;
    if (!this.usage[request.model]) {
      const model = this.modelInfo[request.model];
      this.usage[request.model] = {
        model,
        modelUsage: {
          promptTokens: 0,
          completionTokens: 0,
          apiCalls: 0,
          totalCost: 0
        }
      };
    }
    this.usage[request.model].modelUsage.promptTokens += promptTokens;
    this.usage[request.model].modelUsage.apiCalls += 1;
    let calledFunction = "";
    if (request.functions && request.functions.length > 0) {
      calledFunction = request.functions[0].name;
    }
    if (calledFunction) {
      if (calledFunction === "choice") {
        const choiceFunction = (_a2 = request.functions) == null ? void 0 : _a2.find(
          (fn) => fn.name === "choice"
        );
        if (!choiceFunction) {
          throw Error("No choice function found");
        }
        return this.createMockChoiceFunctionResponse(
          choiceFunction
        );
      } else if (calledFunction === "form") {
        const formFunction = (_b = request.functions) == null ? void 0 : _b.find(
          (fn) => fn.name === "form"
        );
        if (!formFunction) {
          throw Error("No form function found");
        }
        return this.createMockFormFunctionResponse(
          formFunction
        );
      } else if (calledFunction === "note_select") {
        const noteNameFunction = (_c = request.functions) == null ? void 0 : _c.find(
          (fn) => fn.name === "note_select"
        );
        if (!noteNameFunction) {
          throw Error("No note select function found");
        }
        return this.createMockNoteNameFunctionResponse(
          noteNameFunction
        );
      }
    }
    return {
      role: "assistant",
      content: "Mock response"
    };
  }
  createMockChoiceFunctionResponse(choiceFunction) {
    const parsedProperties = JSON.parse(
      JSON.stringify(choiceFunction == null ? void 0 : choiceFunction.parameters["properties"])
    );
    const randomChoice = parsedProperties.choice.enum[Math.floor(Math.random() * parsedProperties.choice.enum.length)];
    return {
      role: "assistant",
      function_call: {
        name: "choice",
        arguments: `{
					"choice" : "${randomChoice}"
					}`
      }
    };
  }
  createMockFormFunctionResponse(listFunction) {
    const args = [];
    for (const property of Object.keys(
      listFunction == null ? void 0 : listFunction.parameters["properties"]
    )) {
      args.push({
        [property]: "Mock answer"
      });
    }
    return {
      role: "assistant",
      function_call: {
        name: "form",
        arguments: JSON.stringify(args)
      }
    };
  }
  createMockNoteNameFunctionResponse(noteFunction) {
    const args = [];
    const parsedProperties = JSON.parse(
      JSON.stringify(noteFunction == null ? void 0 : noteFunction.parameters["properties"])
    );
    const randomNote = parsedProperties.note.enum[Math.random() * parsedProperties.note.enum.length];
    args.push({
      note: randomNote
    });
    return {
      role: "assistant",
      function_call: {
        name: "note_select",
        arguments: JSON.stringify(args)
      }
    };
  }
  createChoiceFunction(choices) {
    return {
      name: "choice",
      description: "Enter your choice using this function.",
      parameters: {
        type: "object",
        properties: {
          choice: {
            type: "string",
            enum: choices
          }
        },
        required: ["choice"]
      }
    };
  }
  createFormFunction(tags) {
    const properties = {};
    tags.forEach((tag) => {
      if (tag.noteNames) {
        properties[tag.name] = {
          type: "string",
          enum: tag.noteNames
        };
        return;
      }
      properties[tag.name] = {
        type: "string"
      };
    });
    return {
      name: "form",
      description: "Use this function to enter the requested information for each key.",
      parameters: {
        type: "object",
        properties,
        required: tags.map((tag) => tag.name)
      }
    };
  }
  createNoteNameFunction(notes) {
    return {
      name: "note_select",
      description: "Enter one of the provided valid note names.",
      parameters: {
        type: "object",
        properties: {
          note: {
            type: "string",
            enum: notes
          }
        },
        required: ["note"]
      }
    };
  }
  calculateAllLLMCosts() {
    for (const usage of Object.values(this.usage)) {
      usage.modelUsage.totalCost = this.calculateLLMCostForModel(usage);
    }
    return this.usage;
  }
  calculateLLMCostForModel(usage) {
    const promptCost = usage.model.promptTokenPrice * usage.modelUsage.promptTokens;
    const completionCost = usage.model.completionTokenPrice * usage.modelUsage.completionTokens;
    const totalCost = promptCost + completionCost;
    return totalCost;
  }
  getTotalCost() {
    let totalCost = 0;
    for (const usage of Object.values(this.usage)) {
      totalCost += this.calculateLLMCostForModel(usage);
    }
    return totalCost;
  }
  createHttpTemplate(inputString) {
    const lines = inputString.split("\n");
    const nameLine = lines[0];
    let jsonString = lines.slice(1).join("\n");
    if (jsonString.startsWith("```")) {
      jsonString = jsonString.substring(3, jsonString.length - 3);
    }
    if (jsonString.startsWith("json")) {
      jsonString = jsonString.substring(4, jsonString.length);
    }
    const name = nameLine.substring(1, nameLine.length - 1).trim();
    const json2 = JSON.parse(jsonString);
    const httpTemplate = {
      id: "",
      // Using an empty string for the ID as specified
      name,
      url: json2.url,
      method: json2.method,
      headers: json2.headers,
      bodyTemplate: JSON.stringify(json2.bodyTemplate)
    };
    return httpTemplate;
  }
  async executeHttpTemplateFromFloatingNode(inputString, body) {
    if (this.isMock) {
      return "Mock response";
    }
    let template;
    try {
      template = this.createHttpTemplate(inputString);
    } catch (error) {
      return new Error(
        `Failed to create HTTP template from input string: ${error.message}`
      );
    }
    try {
      return await this.executeHttpTemplate(template, body);
    } catch (error) {
      return error;
    }
  }
  async executeHttpTemplateByName(name, body) {
    if (this.isMock) {
      return "Mock response";
    }
    if (!this.cannoli.settings.httpTemplates) {
      return new Error(
        "No HTTP templates available. You can add them in Cannoli Plugin settings."
      );
    }
    const template = this.cannoli.settings.httpTemplates.find(
      (template2) => template2.name === name
    );
    if (!template) {
      return new Error(`HTTP template with name "${name}" not found.`);
    }
    try {
      return await this.executeHttpTemplate(template, body);
    } catch (error) {
      return error;
    }
  }
  executeHttpTemplate(template, body) {
    return new Promise((resolve, reject) => {
      let requestBody;
      if (template.bodyTemplate) {
        requestBody = this.parseBodyTemplate(
          template.bodyTemplate,
          body || ""
        );
      } else {
        if (typeof body === "string") {
          requestBody = body;
        } else {
          requestBody = JSON.stringify(body);
        }
      }
      const options = {
        method: template.method,
        headers: template.headers,
        body: template.method.toLowerCase() !== "get" ? requestBody : void 0
      };
      if (this.isMock) {
        resolve("mock response");
      }
      {
        (0, import_obsidian.requestUrl)({ ...options, url: template.url }).then((response) => {
          return response.text;
        }).then((text) => {
          let response;
          if (text.length > 0) {
            response = JSON.parse(text);
          } else {
            response = {};
          }
          if (response.status >= 400) {
            reject(
              new Error(
                `HTTP error ${response.status}: ${response.statusText}`
              )
            );
          } else {
            resolve(JSON.stringify(response, null, 2));
          }
        }).catch((error) => {
          reject(
            new Error(`Error on HTTP request: ${error.message}`)
          );
        });
      }
    });
  }
  async editNote(reference, newContent, append) {
    var _a2, _b, _c, _d, _e, _f, _g;
    if (this.isMock) {
      return;
    }
    const filename = reference.name.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return null;
    }
    if (append) {
      await this.cannoli.app.vault.process(file, (content) => {
        return content + newContent;
      });
      if (((_b = (_a2 = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _a2.file) == null ? void 0 : _b.basename) === file.basename) {
        const userTemplate = "\n\n" + ((_c = this.cannoli.settings.chatFormatString) == null ? void 0 : _c.replace("{{role}}", "User").replace("{{content}}", ""));
        if (newContent === userTemplate) {
          await new Promise((resolve) => setTimeout(resolve, 40));
        }
        if (this.cannoli.settings.autoScrollWithTokenStream) {
          (_g = (_d = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _d.editor) == null ? void 0 : _g.setCursor(
            ((_f = (_e = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _e.editor) == null ? void 0 : _f.lineCount()) || 0,
            0
          );
        }
      }
    } else {
      if (reference.includeProperties) {
        await this.cannoli.app.vault.modify(file, newContent);
      } else {
        await this.cannoli.app.vault.process(file, (content) => {
          var _a3;
          const yamlFrontmatter = (_a3 = content.match(
            /^---\n[\s\S]*?\n---\n/
          )) == null ? void 0 : _a3[0];
          if (yamlFrontmatter) {
            return yamlFrontmatter + newContent;
          } else {
            return newContent;
          }
        });
      }
    }
    return;
  }
  async getNote(reference, recursionCount = 0) {
    var _a2, _b, _c, _d, _e;
    if (this.isMock) {
      return `# ${reference.name}
Mock note content`;
    }
    const filename = reference.name.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return null;
    }
    let content = await this.cannoli.app.vault.read(file);
    if (reference.subpath) {
      const metadata = this.cannoli.app.metadataCache.getCache(file.path);
      if (!metadata)
        return null;
      const subpath = (0, import_obsidian.resolveSubpath)(metadata, reference.subpath);
      if (!subpath)
        return null;
      const startLine = subpath.start.line;
      const endLine = (_b = (_a2 = subpath.end) == null ? void 0 : _a2.line) != null ? _b : null;
      const lines = content.split("\n");
      if (endLine) {
        if (startLine === endLine) {
          return lines[startLine].trim();
        } else {
          content = lines.slice(startLine, endLine).join("\n");
        }
      } else {
        content = lines.slice(startLine).join("\n");
      }
      content = content.trim();
      if (content === "") {
        return null;
      }
    } else {
      if ((_c = reference.includeProperties) != null ? _c : this.cannoli.settings.includePropertiesInExtractedNotes) {
      } else {
        const yamlFrontmatter = (_d = content.match(
          /^---\n[\s\S]*?\n---\n/
        )) == null ? void 0 : _d[0];
        if (yamlFrontmatter) {
          content = content.replace(yamlFrontmatter, "");
        }
      }
      if ((_e = reference.includeName) != null ? _e : this.cannoli.settings.includeFilenameAsHeader) {
        const header = `# ${file.basename}
`;
        content = header + content;
      }
    }
    const embeddedNotes = content.match(/!\[\[[\s\S]*?\]\]/g);
    if (embeddedNotes) {
      for (const embeddedNote of embeddedNotes) {
        let noteName = embeddedNote.replace("![[", "").replace("]]", "");
        let subpath;
        if (noteName.includes("|")) {
          noteName = noteName.split("|")[0];
        }
        if (noteName.includes("#")) {
          const split = noteName.split("#");
          noteName = split[0];
          subpath = split[1];
        }
        if (noteName === reference.name) {
          continue;
        }
        if (recursionCount > 10) {
          console.error(
            `Recursion limit reached while extracting note "${noteName}".`
          );
          continue;
        }
        const noteContent = await this.getNote(
          {
            name: noteName,
            type: "note" /* Note */,
            shouldExtract: true,
            includeName: true,
            subpath
          },
          recursionCount + 1
        );
        if (noteContent) {
          const blockquotedNoteContent = "> " + noteContent.replace(/\n/g, "\n> ");
          content = content.replace(
            embeddedNote,
            blockquotedNoteContent
          );
        }
      }
    }
    return content;
  }
  editSelection(newContent) {
    var _a2, _b;
    if (this.isMock) {
      return;
    }
    if (!this.cannoli.app.workspace.activeEditor) {
      return;
    }
    (_b = (_a2 = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _a2.editor) == null ? void 0 : _b.replaceSelection(
      newContent
    );
  }
  async getPropertyOfNote(noteName, propertyName, yamlFormat = false) {
    const filename = noteName.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return null;
    }
    try {
      let frontmatter = {};
      await this.cannoli.app.fileManager.processFrontMatter(
        file,
        (content) => {
          frontmatter = content;
          return content;
        }
      );
      if (!frontmatter) {
        return null;
      }
      const property = frontmatter[propertyName];
      if (typeof property !== "string") {
        if (yamlFormat) {
          return dump(property);
        } else {
          return JSON.stringify(frontmatter[propertyName], null, 2);
        }
      } else {
        return property;
      }
    } catch (error) {
      console.error(
        "An error occurred while fetching frontmatter:",
        error
      );
      return null;
    }
  }
  async getAllPropertiesOfNote(noteName, yamlFormat = false) {
    const filename = noteName.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return null;
    }
    try {
      let frontmatter = {};
      await this.cannoli.app.fileManager.processFrontMatter(
        file,
        (content) => {
          frontmatter = content;
          return content;
        }
      );
      if (!frontmatter) {
        return null;
      }
      if (!yamlFormat) {
        return JSON.stringify(frontmatter, null, 2);
      } else {
        return dump(frontmatter);
      }
    } catch (error) {
      console.error(
        "An error occurred while fetching frontmatter:",
        error
      );
      return null;
    }
  }
  async editPropertyOfNote(noteName, propertyName, newValue) {
    const filename = noteName.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return;
    }
    let parsedNewValue = newValue;
    if (newValue.startsWith("- ")) {
      parsedNewValue = newValue.split("\n").map((item) => item.replace("- ", "").trim()).filter((item) => item !== "");
    }
    try {
      await this.cannoli.app.fileManager.processFrontMatter(
        file,
        (content) => {
          let frontmatter = {};
          if (content) {
            frontmatter = content;
          }
          frontmatter[propertyName] = parsedNewValue;
          return frontmatter;
        }
      );
      return;
    } catch (error) {
      console.error(
        "An error occurred while editing frontmatter:",
        error
      );
      return;
    }
  }
  async createNoteAtExistingPath(noteName, path, content, verbose = false) {
    noteName = noteName.replace("[[", "").replace("]]", "");
    let i = 1;
    while (this.cannoli.app.metadataCache.getFirstLinkpathDest(noteName, "")) {
      if (noteName.match(/ \d+$/)) {
        noteName = noteName.replace(/ \d+$/, ` ${i.toString()}`);
      } else {
        noteName = `${noteName} ${i.toString()}`;
      }
      i++;
    }
    const fullPath = `${path != null ? path : ""}/${noteName}.md`;
    await this.cannoli.app.vault.create(fullPath, content != null ? content : "");
    if (verbose) {
      console.log(`Note "${noteName}" created at path "${fullPath}"`);
    }
    return noteName;
  }
  async createNoteAtNewPath(noteName, path, content, verbose = false) {
    const fullPath = `${path}/${noteName}.md`;
    await this.cannoli.app.vault.create(fullPath, content != null ? content : "");
    if (verbose) {
      console.log(`Note "${noteName}" created at path "${fullPath}"`);
    }
    return true;
  }
  async getNotePath(noteName) {
    const filename = noteName.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return null;
    }
    return file.path;
  }
  async createFolder(path, verbose = false) {
    const folder = this.cannoli.app.vault.getAbstractFileByPath(path);
    if (folder) {
      return false;
    }
    this.cannoli.app.vault.createFolder(path);
    if (verbose) {
      console.log(`Folder created at path "${path}"`);
    }
    return true;
  }
  async moveNote(noteName, newPath, verbose = false) {
    const newFullPath = `${newPath}/${noteName}.md`;
    const filename = noteName.replace("[[", "").replace("]]", "");
    const note = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    const oldFullPath = note == null ? void 0 : note.path;
    if (!note) {
      return false;
    }
    await this.cannoli.app.vault.rename(note, newFullPath);
    if (verbose) {
      console.log(
        `Note "${noteName}" moved from path "${oldFullPath}" to path "${newFullPath}"`
      );
    }
    return true;
  }
  logGraph() {
    for (const node of Object.values(this.graph)) {
      console.log(node.logDetails());
    }
  }
};

// assets/cannoliCollege.js
var cannoliCollege = {
  "1. Basics": [
    {
      name: "1. Hello world.canvas",
      content: `{"nodes":[{"type":"group","id":"161279baf7763214","x":-174,"y":-160,"width":394,"height":340,"label":"Cannoli"},{"type":"text","text":"Hello world!","id":"dc3f9351f787531e","x":-97,"y":-91,"width":250,"height":60},{"type":"text","text":"","id":"bc1a550bbb4aac7b","x":-97,"y":60,"width":250,"height":60,"color":"6"},{"type":"text","text":"The purple node is a content node. Content nodes can be used to store and display text that can be read or written by you or another node.","id":"f77169b141243e65","x":240,"y":30,"width":420,"height":120},{"type":"text","text":"The colorless, green, or yellow node is a call node. Call nodes make a chat completion call to the LLM with the text of the node as a user message.","id":"0af5a453bd4d6ec9","x":240,"y":-110,"width":380,"height":120},{"type":"text","text":"If a node in a cannoli is floating (no arrows attached) it won't affect the cannoli unless it is formatted in a special way we'll go over later.","id":"7d005c80299f3674","x":-202,"y":220,"width":461,"height":112},{"type":"text","text":"This is a Cannoli. It's made up of different types of nodes and arrows.\\n\\nTry running it by clicking the Cannoli button in the control ribbon on the left side of your Obsidian window.","id":"24dd96c964700992","x":-147,"y":-400,"width":350,"height":180},{"type":"text","text":"Cannolis can be run in several ways:\\n\\n- Click the Cannoli ribbon icon\\n    - If you're on a canvas file, it will be run as a cannoli\\n    - If you're on a note with a \\"cannoli\\" property, the canvas file in that property will be run as a cannoli\\n- Run the \\"Start/Stop cannoli\\" command in the command palette (functions the same as the ribbon icon)\\n- If a canvas file name ends with \\".cno\\", it will have its own run command in the command palette\\n- Make an audio recording on a note with a \\"cannoli\\" property\\n\\t- That recording will be transcribed, replace the reference, and trigger the cannoli defined in the property.","id":"927cf33512b0dfc1","x":-740,"y":-182,"width":538,"height":402}],"edges":[{"id":"23c2d7dffb49bf75","fromNode":"dc3f9351f787531e","fromSide":"bottom","toNode":"bc1a550bbb4aac7b","toSide":"top"}]}`
    },
    {
      name: "2. Blank arrows.canvas",
      content: `{"nodes":[{"type":"group","id":"e77c462deb61200c","x":-200,"y":-240,"width":360,"height":600,"label":"Blank Arrows"},{"type":"text","text":"This first arrow is going from a call node to another call node, so it will pass the chat history along.","id":"ab7c414710f7f130","x":-478,"y":-160,"width":268,"height":135},{"type":"text","text":"The third arrow is going from a content node to a content node, so it will just copy its content.","id":"ccd789ee75f32cfa","x":-513,"y":191,"width":303,"height":102},{"type":"text","text":"This is the second user message, after an LLM response","id":"78cc7edc0acf7754","x":-145,"y":-39,"width":250,"height":110},{"type":"text","text":"This is the first user message","id":"f20327851c3175bd","x":-145,"y":-190,"width":250,"height":60},{"type":"text","text":"","id":"ffdc926f780c7c6f","x":-145,"y":131,"width":250,"height":60,"color":"6"},{"type":"text","text":"","id":"2a451cf329dad9eb","x":-145,"y":260,"width":250,"height":60,"color":"6"},{"type":"text","text":"The second arrow is going to a content node, so it will just pass the content of the LLM's response along.","id":"69c75646befb238b","x":170,"y":49,"width":344,"height":112},{"type":"text","text":"Arrows behave differently depending on their color, their label, and the type of their source and target (the node they are coming from and the node they point to).","id":"7f3c629307341974","x":-210,"y":-440,"width":380,"height":130}],"edges":[{"id":"3e2d98fc5ddeb168","fromNode":"78cc7edc0acf7754","fromSide":"bottom","toNode":"ffdc926f780c7c6f","toSide":"top"},{"id":"321db5e7d72b0151","fromNode":"ffdc926f780c7c6f","fromSide":"bottom","toNode":"2a451cf329dad9eb","toSide":"top"},{"id":"d08c98406e290f66","fromNode":"f20327851c3175bd","fromSide":"bottom","toNode":"78cc7edc0acf7754","toSide":"top"}]}`
    },
    {
      name: "3. Branching.canvas",
      content: `{"nodes":[{"type":"group","id":"7c382706de4d0696","x":-160,"y":-409,"width":695,"height":770,"label":"Multiple outgoing arrows"},{"type":"group","id":"5a24d53646b10364","x":-132,"y":480,"width":640,"height":480,"label":"Branching chats"},{"type":"text","text":"In this case, we are sending the output of each call node to a content node as well as another call node.\\n\\nThis shows us the LLM's response to each user message.","id":"a920f9e049043602","x":-460,"y":-228,"width":280,"height":240},{"type":"text","text":"","id":"69ab78708b319e8d","x":140,"y":-329,"width":340,"height":110,"color":"6"},{"type":"text","text":"","id":"c096758e55238bfe","x":175,"y":-178,"width":340,"height":250,"color":"6"},{"type":"text","text":"What's the best Italian dessert?","id":"7b37496e496da827","x":-137,"y":-359,"width":250,"height":60},{"type":"text","text":"How do you make it?","id":"aea9dcb543944bb1","x":-137,"y":-189,"width":250,"height":60},{"type":"text","text":"Give me a simpler recipe","id":"2f59408c2be9b7ae","x":-137,"y":12,"width":250,"height":60},{"type":"text","text":"","id":"ddb05069cb9f6f3e","x":113,"y":137,"width":390,"height":190,"color":"6"},{"type":"text","text":"Nodes can have multiple arrows coming out of them. They can carry information to different kinds of nodes.","id":"6d316338bfce7b20","x":28,"y":-580,"width":340,"height":100},{"type":"text","text":"Nf3","id":"248594446ba6eca2","x":-97,"y":691,"width":250,"height":60},{"type":"text","text":"Lets play chess. Here's my first move: e4","id":"891f6d7945759cd7","x":69,"y":500,"width":250,"height":60},{"type":"text","text":"Nc3","id":"5d4454ca8f7bdb3a","x":228,"y":691,"width":250,"height":60},{"type":"text","text":"","id":"3492caf4ead7f8cb","x":-107,"y":853,"width":260,"height":78,"color":"6"},{"type":"text","text":"","id":"9f9ba5852d437657","x":228,"y":853,"width":254,"height":78,"color":"6"},{"type":"text","text":"We can also use multiple outgoing arrows to create different branches of a chat","id":"5347076c683c8346","x":-392,"y":680,"width":255,"height":104}],"edges":[{"id":"d8d4ab1340924892","fromNode":"2f59408c2be9b7ae","fromSide":"bottom","toNode":"ddb05069cb9f6f3e","toSide":"left"},{"id":"806865b0c75a6687","fromNode":"aea9dcb543944bb1","fromSide":"bottom","toNode":"2f59408c2be9b7ae","toSide":"top"},{"id":"44a20edc995a84d8","fromNode":"aea9dcb543944bb1","fromSide":"bottom","toNode":"c096758e55238bfe","toSide":"left"},{"id":"b59766f15e6812d8","fromNode":"7b37496e496da827","fromSide":"bottom","toNode":"aea9dcb543944bb1","toSide":"top"},{"id":"8fd655a2583e6f98","fromNode":"7b37496e496da827","fromSide":"bottom","toNode":"69ab78708b319e8d","toSide":"left"},{"id":"7d1bb4c2b5052c34","fromNode":"891f6d7945759cd7","fromSide":"bottom","toNode":"248594446ba6eca2","toSide":"top"},{"id":"bc0b97379618ae28","fromNode":"891f6d7945759cd7","fromSide":"bottom","toNode":"5d4454ca8f7bdb3a","toSide":"top"},{"id":"08fda0370caa615e","fromNode":"248594446ba6eca2","fromSide":"bottom","toNode":"3492caf4ead7f8cb","toSide":"top"},{"id":"e1a68493483394b4","fromNode":"5d4454ca8f7bdb3a","fromSide":"bottom","toNode":"9f9ba5852d437657","toSide":"top"}]}`
    },
    {
      name: "4. System messages.canvas",
      content: `{"nodes":[{"type":"group","id":"9a74aa8d0afdb942","x":-334,"y":-395,"width":669,"height":790,"label":"System Messages"},{"type":"text","text":"You are a silly goofy guy","id":"d005ba1be8656e6e","x":-314,"y":-205,"width":250,"height":60,"color":"6"},{"type":"text","text":"Hey what's a fun outing","id":"2c1e68fdaf20b936","x":-314,"y":-25,"width":250,"height":60},{"type":"text","text":"","id":"606e8b604062817a","x":-314,"y":111,"width":250,"height":154,"color":"6"},{"type":"text","text":"","id":"d0edacf3895cacc4","x":65,"y":-95,"width":250,"height":155,"color":"6"},{"type":"text","text":"Respond with a description of a very confused AI assistant that can't keep it together. Nothing else should be in your response. It should start with: \\"you are a...\\"","id":"59b7fc9dda9a50c1","x":65,"y":-375,"width":250,"height":232},{"type":"text","text":"This call node will include the above content node text as a system message.","id":"4b95de6b15e52400","x":-620,"y":-45,"width":260,"height":125},{"type":"text","text":"Here we're using a call node to generate a system message.","id":"9f14bc97186eabc0","x":360,"y":-143,"width":260,"height":98},{"type":"text","text":"Who invented mail?","id":"b8465e3c0926341e","x":65,"y":111,"width":250,"height":60},{"type":"text","text":"Blank arrows going from content nodes to call nodes will pass their content as a system message. System messages are used to give instructions on how the LLM should respond to user messages.","id":"225fa9e654db31d6","x":-189,"y":-620,"width":414,"height":157},{"type":"text","text":"","id":"661a61495dfeaf24","x":65,"y":218,"width":250,"height":157,"color":"6"}],"edges":[{"id":"4cfad5a8ec2be98f","fromNode":"d005ba1be8656e6e","fromSide":"bottom","toNode":"2c1e68fdaf20b936","toSide":"top"},{"id":"2a357972e7682b3d","fromNode":"2c1e68fdaf20b936","fromSide":"bottom","toNode":"606e8b604062817a","toSide":"top"},{"id":"c19d63a0e7873549","fromNode":"d0edacf3895cacc4","fromSide":"bottom","toNode":"b8465e3c0926341e","toSide":"top"},{"id":"04fc452e98f4b80f","fromNode":"59b7fc9dda9a50c1","fromSide":"bottom","toNode":"d0edacf3895cacc4","toSide":"top"},{"id":"ff5fd1f32d515a9f","fromNode":"b8465e3c0926341e","fromSide":"bottom","toNode":"661a61495dfeaf24","toSide":"top"}]}`
    },
    {
      name: "5. Variable arrows.canvas",
      content: `{"nodes":[{"type":"group","id":"4dd63eded63256f2","x":-172,"y":240,"width":665,"height":460,"label":"Multiple variables"},{"type":"group","id":"d83444fe5b49fb2c","x":-160,"y":800,"width":653,"height":463,"label":"Between call nodes"},{"type":"group","id":"c409a28317a5ae26","x":11,"y":-360,"width":294,"height":510,"label":"Variables"},{"type":"text","text":"Pannetone","id":"0d48f7722e5db52e","x":31,"y":-340,"width":250,"height":60,"color":"6"},{"type":"text","text":"The label of the arrow names the variable, and you can inject it into a call node using the format \\"{{variable name}}\\"","id":"1a3b5db348375dba","x":-380,"y":-199,"width":371,"height":119},{"type":"text","text":"How do you make {{dessert}}?","id":"10cedae5ccf81664","x":31,"y":-180,"width":250,"height":60},{"type":"text","text":"","id":"5cf958d72a55d52d","x":32,"y":-24,"width":250,"height":154,"color":"6"},{"type":"text","text":"Labeling an arrow makes it a variable you can access in call nodes.","id":"db8924f8ddaaa08e","x":-13,"y":-520,"width":330,"height":86},{"type":"text","text":"Hannibal","id":"b2aa8b695a7b7774","x":-152,"y":260,"width":250,"height":60,"color":"6"},{"type":"text","text":"Elephants","id":"c23271f22630c4a9","x":223,"y":260,"width":250,"height":60,"color":"6"},{"type":"text","text":"What connects {{a}} and {{b}}?","id":"4f84654825f9df4c","x":34,"y":420,"width":293,"height":75},{"type":"text","text":"You can name and inject the output of call nodes the same way.","id":"835c4e523796df6e","x":-500,"y":915,"width":320,"height":80},{"type":"text","text":"Rate this limerick:\\n{{limerick}}","id":"25d842fe884f4e78","x":-140,"y":995,"width":250,"height":60},{"type":"text","text":"Respond with a limerick about Cannolis","id":"1714bc9f52099a91","x":-140,"y":820,"width":250,"height":60},{"type":"text","text":"","id":"84fb2c8243704c1a","x":55,"y":550,"width":250,"height":130,"color":"6"},{"type":"text","text":"","id":"13cde1cb12272304","x":-140,"y":1110,"width":250,"height":133,"color":"6"},{"type":"text","text":"Are you sure its {{city}}?","id":"fe8260fd047fe01a","x":192,"y":996,"width":250,"height":60},{"type":"text","text":"","id":"26d4da45eb95d333","x":192,"y":1110,"width":250,"height":133,"color":"6"},{"type":"text","text":"What's the capital of Italy?","id":"44d0ee25c2f23e66","x":192,"y":820,"width":250,"height":60},{"type":"text","text":"Multiple arrows going into a call node can be used to inject multiple variables.","id":"0fd0a4b39c942f0b","x":-426,"y":399,"width":246,"height":117},{"type":"text","text":"Labeled basic arrows between call nodes will not pass along the chat history by default, only the content of the response.\\n\\nYou can override this by adding a \\"|\\" symbol at the end of the arrow label like so. Then you can continue a conversation as well as use a variable.","id":"1fadbba4649fa725","x":520,"y":955,"width":380,"height":245}],"edges":[{"id":"139dad9317421572","fromNode":"0d48f7722e5db52e","fromSide":"bottom","toNode":"10cedae5ccf81664","toSide":"top","label":"dessert"},{"id":"fa1b26557addc3e5","fromNode":"b2aa8b695a7b7774","fromSide":"bottom","toNode":"4f84654825f9df4c","toSide":"top","label":"a"},{"id":"ece89fb689451485","fromNode":"c23271f22630c4a9","fromSide":"bottom","toNode":"4f84654825f9df4c","toSide":"top","label":"b"},{"id":"b9eadfcbf2c54fe1","fromNode":"10cedae5ccf81664","fromSide":"bottom","toNode":"5cf958d72a55d52d","toSide":"top"},{"id":"3a41dc5849268edf","fromNode":"4f84654825f9df4c","fromSide":"bottom","toNode":"84fb2c8243704c1a","toSide":"top"},{"id":"7cf5bbc070866504","fromNode":"25d842fe884f4e78","fromSide":"bottom","toNode":"13cde1cb12272304","toSide":"top"},{"id":"3b347865a761d32b","fromNode":"1714bc9f52099a91","fromSide":"bottom","toNode":"25d842fe884f4e78","toSide":"top","label":"limerick"},{"id":"f93a6b2b699a1bf6","fromNode":"44d0ee25c2f23e66","fromSide":"bottom","toNode":"fe8260fd047fe01a","toSide":"top","label":"city|"},{"id":"0fa4378c8752aca4","fromNode":"fe8260fd047fe01a","fromSide":"bottom","toNode":"26d4da45eb95d333","toSide":"top"}]}`
    }
  ],
  "2. Special arrows": [
    {
      name: "1. Config arrows.canvas",
      content: `{"nodes":[{"type":"group","id":"b388b74fc76f9d5b","x":-411,"y":420,"width":800,"height":480,"label":"Config Arrows"},{"type":"group","id":"50e47210c3597f2c","x":-382,"y":-274,"width":742,"height":442,"label":"Logging Arrows"},{"type":"text","text":"What's the weakest?","id":"01b6cd0557436d0d","x":-362,"y":77,"width":250,"height":60},{"type":"text","text":"You're an expert in metallurgy","id":"cd8bccad9c0ff0e1","x":-362,"y":-254,"width":250,"height":60,"color":"6"},{"type":"text","text":"What's the strongest metal?","id":"d90d1eda5b1cee39","x":-362,"y":-94,"width":250,"height":60},{"type":"text","text":"The logging arrow will write the chat history, response, and config of the call node to the content node it is pointing to.","id":"82607dbca24bcc3b","x":-720,"y":48,"width":325,"height":120},{"type":"text","text":"As a cannoli gets more complex, it can be difficult to know what the LLM is actually seeing in each call node.\\n\\nA blank config arrow leaving a call node will log out everything the LLM saw on that call, as well as the config of that call node.","id":"2eddfb2df05ffd92","x":-932,"y":-224,"width":537,"height":160},{"type":"text","text":"Orange arrows are config arrows. You can change the color of arrows by left clicking on them and then clicking on the color pallet ","id":"f1b3951087221764","x":-160,"y":-440,"width":393,"height":118},{"type":"text","text":"","id":"18629c0795e99c52","x":-28,"y":-158,"width":365,"height":295,"color":"6"},{"type":"text","text":"Labeled config arrows pointing to call nodes will try to set their content to the LLM config setting named in the arrow's label.","id":"9750898ccab8b2ec","x":-190,"y":240,"width":325,"height":130},{"type":"text","text":"1.5","id":"f2066662ccfdf12b","x":-228,"y":450,"width":106,"height":68,"color":"6"},{"type":"text","text":"When will gpt-5 come out?","id":"901e534d654dbe8d","x":-285,"y":640,"width":250,"height":60},{"type":"text","text":"gpt-4","id":"32895b9cbe65ebf5","x":-385,"y":450,"width":100,"height":60,"color":"6"},{"type":"text","text":"","id":"f9768071dcaaf641","x":24,"y":445,"width":345,"height":415,"color":"6"},{"type":"text","text":"Config arrows can also be used to set the LLM config of call nodes, overriding the default.","id":"f75c463c060098f5","x":-760,"y":442,"width":324,"height":106},{"type":"text","text":"This call node will request a gpt-4 response with a temperature of 1.5, overriding the defaults.\\n\\n(You can set the defaults in the plugin settings)","id":"1a6e63c23f2fd598","x":-760,"y":581,"width":324,"height":179}],"edges":[{"id":"3e19de32f2cf2234","fromNode":"01b6cd0557436d0d","fromSide":"right","toNode":"18629c0795e99c52","toSide":"left","color":"2"},{"id":"a5ea03afb9e7519f","fromNode":"d90d1eda5b1cee39","fromSide":"bottom","toNode":"01b6cd0557436d0d","toSide":"top"},{"id":"e60e398ffd796673","fromNode":"cd8bccad9c0ff0e1","fromSide":"bottom","toNode":"d90d1eda5b1cee39","toSide":"top"},{"id":"4802b580405f5936","fromNode":"f2066662ccfdf12b","fromSide":"bottom","toNode":"901e534d654dbe8d","toSide":"top","color":"2","label":"temperature"},{"id":"44d9a85dc1209c3f","fromNode":"901e534d654dbe8d","fromSide":"right","toNode":"f9768071dcaaf641","toSide":"left","color":"2"},{"id":"18f98f277862e948","fromNode":"32895b9cbe65ebf5","fromSide":"bottom","toNode":"901e534d654dbe8d","toSide":"left","color":"2","label":"model"}]}`
    },
    {
      name: "2. Field arrows.canvas",
      content: `{"nodes":[{"type":"group","id":"ac03334c4c9efbbf","x":-300,"y":320,"width":871,"height":540,"label":"Other details"},{"type":"group","id":"bb74df853c72868d","x":-240,"y":-80,"width":600,"height":328,"label":"Field arrows"},{"type":"text","text":"What's a good fruit to eat for each meal?","id":"bf2f302f415a57a7","x":-97,"y":-60,"width":250,"height":60},{"type":"text","text":"","id":"8eee16509fba3a49","x":-214,"y":168,"width":140,"height":60,"color":"6"},{"type":"text","text":"When a call node has field arrows leaving it, that call will include a function that gives the LLM fields to fill out for each field name you provide.","id":"c812856c4f5cfe60","x":-560,"y":-80,"width":309,"height":158},{"type":"text","text":"Choosing field arrow names is its own kind of prompting. Experiment with different ways of naming the arrows to get better results.","id":"bf823c055e81ed66","x":-560,"y":97,"width":309,"height":143},{"type":"text","text":"Purple arrows are field arrows. Field arrows are a special kind of variable arrow that allow you to name a field for the LLM to fill. \\n\\nThey use openai's function calling feature to get structured responses based on the arrow labels.","id":"972a9b4042c99aff","x":-160,"y":-320,"width":444,"height":186},{"type":"text","text":"Rank the top 2 most famous historical battles","id":"912a11d4e1afa3c1","x":-74,"y":340,"width":250,"height":60},{"type":"text","text":"","id":"7fcb2dd5de840465","x":-280,"y":600,"width":332,"height":241,"color":"6"},{"type":"text","text":"What makes the {{battle 1}} famous?","id":"b9016ed068d8f3df","x":-214,"y":496,"width":254,"height":60},{"type":"text","text":"","id":"fc3f0539962083c5","x":-33,"y":168,"width":122,"height":60,"color":"6"},{"type":"text","text":"","id":"303f2609904e9a78","x":153,"y":168,"width":180,"height":60,"color":"6"},{"type":"text","text":"","id":"b58f716ac95e1bd3","x":81,"y":600,"width":339,"height":241,"color":"6"},{"type":"text","text":"What makes the {{battle 2}} famous?","id":"355f89d3338915a0","x":89,"y":496,"width":271,"height":60},{"type":"text","text":"{\\n  \\"battle 1\\": \\"Battle of Waterloo\\",\\n  \\"battle 2\\": \\"Battle of Stalingrad\\"\\n}","id":"602c0eb10399429c","x":251,"y":340,"width":301,"height":120,"color":"6"},{"type":"text","text":"Non-field arrows will just carry the response as a JSON string.","id":"05a12136e3510af7","x":580,"y":340,"width":250,"height":98},{"type":"text","text":"Similarly to variable arrows, by default field arrows don't pass chat history. Override this with a \\"|\\" symbol at the end.","id":"e385c431c950a822","x":-600,"y":435,"width":277,"height":155}],"edges":[{"id":"f243e7ecc26dddf0","fromNode":"bf2f302f415a57a7","fromSide":"bottom","toNode":"8eee16509fba3a49","toSide":"top","color":"6","label":"breakfast"},{"id":"19acdf8c5139a403","fromNode":"bf2f302f415a57a7","fromSide":"bottom","toNode":"fc3f0539962083c5","toSide":"top","color":"6","label":"lunch"},{"id":"eea5e61d628a1f37","fromNode":"bf2f302f415a57a7","fromSide":"bottom","toNode":"303f2609904e9a78","toSide":"top","color":"6","label":"dinner"},{"id":"3e455995e5dff301","fromNode":"912a11d4e1afa3c1","fromSide":"bottom","toNode":"b9016ed068d8f3df","toSide":"top","color":"6","label":"battle 1"},{"id":"de82f8c9cc47e515","fromNode":"912a11d4e1afa3c1","fromSide":"bottom","toNode":"355f89d3338915a0","toSide":"top","color":"6","label":"battle 2|"},{"id":"1a9662bf2fcaaeca","fromNode":"b9016ed068d8f3df","fromSide":"bottom","toNode":"7fcb2dd5de840465","toSide":"top","color":"2"},{"id":"7f6b2d929334d325","fromNode":"355f89d3338915a0","fromSide":"bottom","toNode":"b58f716ac95e1bd3","toSide":"top","color":"2"},{"id":"0d6c132ba45af90d","fromNode":"912a11d4e1afa3c1","fromSide":"right","toNode":"602c0eb10399429c","toSide":"left"}]}`
    },
    {
      name: "3. Choice arrows.canvas",
      content: `{"nodes":[{"type":"group","id":"c9dd6d1bd62bafff","x":-380,"y":380,"width":800,"height":520,"label":"Chat history"},{"type":"group","id":"cd01298f475a3dd6","x":-296,"y":980,"width":578,"height":640,"label":"Variables from different choice paths"},{"type":"group","id":"a6599fe712bec80e","x":-296,"y":-200,"width":604,"height":474,"label":"Choice arrows"},{"type":"text","text":"When a call node has choice arrows leaving it, it will be given a function that asks for a response with one of the arrow labels.","id":"45df9fe6d33cd2d2","x":-660,"y":-140,"width":341,"height":135},{"type":"text","text":"Should I make pasta tonight?","id":"28786f9598c550d5","x":-112,"y":-179,"width":204,"height":79},{"type":"text","text":"You sure?","id":"ac91698a073fc95c","x":-237,"y":6,"width":177,"height":60,"color":"0"},{"type":"text","text":"Ok give me a list of ingredients","id":"63096630fb9f2e2e","x":48,"y":6,"width":230,"height":60},{"type":"text","text":"","id":"3acf958e2220ce5e","x":-273,"y":140,"width":250,"height":114,"color":"6"},{"type":"text","text":"Yellow arrows are choice arrows. Use these to give the LLM a choice between options. Only the arrows that have the chosen label will activate.","id":"4e077ea9cfa98595","x":-175,"y":-368,"width":415,"height":108},{"type":"text","text":"Similarly to blank arrows, choice arrows pass chat history by default.\\n\\nIf you'd like a choice arrow not to pass chat history, and simply define which nodes to activate, add a \\"~\\" symbol at the end of the label.","id":"f258c0364e5303bb","x":-781,"y":400,"width":380,"height":207},{"type":"text","text":"","id":"a5276dfa0b72a1d9","x":38,"y":140,"width":250,"height":114,"color":"6"},{"type":"text","text":"What's the most difficult pasta to make?","id":"03f149b198234b2e","x":-232,"y":400,"width":250,"height":60},{"type":"text","text":"Choice arrows and any other outgoing arrows simply pass the response as a JSON string.","id":"f342c07dfcc12a65","x":440,"y":395,"width":299,"height":109},{"type":"text","text":"","id":"631691e520dac009","x":-355,"y":760,"width":358,"height":120,"color":"6"},{"type":"text","text":"","id":"b217af764ccecfd0","x":28,"y":760,"width":375,"height":120,"color":"6"},{"type":"text","text":"","id":"e82cc2675ee6f4ac","x":140,"y":400,"width":263,"height":60,"color":"6"},{"type":"text","text":"","id":"599128089fbfde0c","x":220,"y":561,"width":183,"height":135,"color":"6"},{"type":"text","text":"Is this my first message?","id":"76252deff058a30b","x":28,"y":641,"width":175,"height":85,"color":"0"},{"type":"text","text":"","id":"32b8f51ebe623e94","x":-369,"y":560,"width":164,"height":135,"color":"6"},{"type":"text","text":"Is this my first message?","id":"c63995fa03f9e524","x":-190,"y":629,"width":166,"height":85},{"type":"text","text":"Write a shopping list based on this recipe: {{a}}","id":"b95eb36f138e1a24","x":-126,"y":1349,"width":250,"height":92},{"type":"text","text":"Which pasta is better for a red sauce?","id":"0fd490ac150e0f5e","x":-143,"y":1000,"width":250,"height":60},{"type":"text","text":"","id":"676ea6885c79b682","x":-185,"y":1480,"width":368,"height":120,"color":"6"},{"type":"text","text":"I dont have any orzo. Respond with a recipe for orzo as well as a recipe for a simple red sauce.","id":"a234933050b99f4f","x":8,"y":1160,"width":250,"height":120,"color":"0"},{"type":"text","text":"Ok I have that. Just respond with the recipe for a simple red sauce.","id":"46b1cd2114123ac8","x":-276,"y":1160,"width":250,"height":120},{"type":"text","text":"If a call node has multiple incoming edges with the same name, only the one from an activated path will be injected.","id":"6e5936cc2c85af89","x":-610,"y":1280,"width":288,"height":137}],"edges":[{"id":"7265ecc0e39454b0","fromNode":"03f149b198234b2e","fromSide":"bottom","toNode":"32b8f51ebe623e94","toSide":"top","color":"3","label":"rigatoni"},{"id":"5b08fd306da75b91","fromNode":"03f149b198234b2e","fromSide":"bottom","toNode":"599128089fbfde0c","toSide":"top","color":"3","label":"linguini"},{"id":"82b732c8452c9584","fromNode":"28786f9598c550d5","fromSide":"bottom","toNode":"ac91698a073fc95c","toSide":"top","color":"3","label":"no"},{"id":"b83dfe178174121d","fromNode":"28786f9598c550d5","fromSide":"bottom","toNode":"63096630fb9f2e2e","toSide":"top","color":"3","label":"yes"},{"id":"b4775fe4758dc40d","fromNode":"ac91698a073fc95c","fromSide":"bottom","toNode":"3acf958e2220ce5e","toSide":"top"},{"id":"ae2322dc9035b985","fromNode":"63096630fb9f2e2e","fromSide":"bottom","toNode":"a5276dfa0b72a1d9","toSide":"top"},{"id":"26d34c5e87e7d03c","fromNode":"03f149b198234b2e","fromSide":"bottom","toNode":"c63995fa03f9e524","toSide":"top","color":"3","label":"rigatoni~"},{"id":"7db7e2a8fc1e1ef6","fromNode":"03f149b198234b2e","fromSide":"bottom","toNode":"76252deff058a30b","toSide":"top","color":"3","label":"linguini~"},{"id":"6f95f372b461f8d5","fromNode":"76252deff058a30b","fromSide":"bottom","toNode":"b217af764ccecfd0","toSide":"top","color":"2"},{"id":"abc25503ba8076fb","fromNode":"c63995fa03f9e524","fromSide":"bottom","toNode":"631691e520dac009","toSide":"top","color":"2"},{"id":"1582d8994ac555e1","fromNode":"03f149b198234b2e","fromSide":"right","toNode":"e82cc2675ee6f4ac","toSide":"left"},{"id":"c43d38e12b9c16b8","fromNode":"46b1cd2114123ac8","fromSide":"bottom","toNode":"b95eb36f138e1a24","toSide":"top","label":"a"},{"id":"f22bc7061eff5703","fromNode":"a234933050b99f4f","fromSide":"bottom","toNode":"b95eb36f138e1a24","toSide":"top","label":"a"},{"id":"bf13cea8fc4d3ac8","fromNode":"0fd490ac150e0f5e","fromSide":"bottom","toNode":"46b1cd2114123ac8","toSide":"top","color":"3","label":"penne"},{"id":"0d60d2b18558d544","fromNode":"0fd490ac150e0f5e","fromSide":"bottom","toNode":"a234933050b99f4f","toSide":"top","color":"3","label":"orzo"},{"id":"96c63376c757dbf0","fromNode":"b95eb36f138e1a24","fromSide":"bottom","toNode":"676ea6885c79b682","toSide":"top"}]}`
    },
    {
      name: "4. Chat arrows.cno.canvas",
      content: '{"nodes":[{"id":"167d3b7b2f6f548d","type":"group","x":-460,"y":400,"width":1004,"height":660,"label":"Limiting chat messages"},{"id":"ec1597e4e7f3530c","type":"group","x":-209,"y":-208,"width":290,"height":348,"label":"Chat arrows"},{"id":"09ce49517baf7eda","type":"text","text":"","x":-189,"y":-60,"width":250,"height":60},{"id":"b90c7fbfa70e4300","type":"text","text":"{{NOTE}}","x":-189,"y":60,"width":250,"height":60,"color":"6"},{"id":"4857524edbae8263","type":"text","text":"This chat arrow will parse the contents of the reference node into an array of messages","x":100,"y":-147,"width":380,"height":87},{"id":"ef3cdc2a117f9156","type":"text","text":"{{NOTE}}","x":-330,"y":420,"width":250,"height":60,"color":"6"},{"id":"82ba7993840f1760","type":"text","text":"","x":-330,"y":568,"width":250,"height":60},{"id":"09a9d8dd0741d74b","type":"text","text":"","x":163,"y":568,"width":250,"height":60},{"id":"9a309223d6ce3931","type":"text","text":"","x":-440,"y":680,"width":471,"height":360,"color":"6"},{"id":"f2d8da368e1c51b6","type":"text","text":"","x":53,"y":680,"width":471,"height":360,"color":"6"},{"id":"cd757b7484ffd798","type":"text","text":"{{NOTE}}","x":163,"y":420,"width":250,"height":60,"color":"6"},{"id":"d9739a4acdf10a34","type":"text","text":"This chat node is empty, so it will just send the previous messages it was given to the LLM","x":-610,"y":-86,"width":343,"height":106},{"id":"2b08e45e39b8eb39","type":"text","text":"This chat arrow will append the content of the response to the same note, as a stream.","x":100,"y":-30,"width":380,"height":120},{"id":"ce80fff3047872f3","type":"text","text":"The final chat arrow only sends the final response, so you can do anything you like with the space between the two chat arrows. \\n\\nUse this flexibility to build chatbots that send http requests, make decisions, edit notes, or gather relevant context.","x":-717,"y":60,"width":459,"height":200},{"id":"1097b1b80a3abe81","type":"text","text":"{{NOTE}}","x":-189,"y":-188,"width":250,"height":60,"color":"6"},{"id":"a8e6750d3ca80fff","type":"text","text":"This is a special reference node that references the note that was active when the cannoli was run.","x":-717,"y":-211,"width":450,"height":83},{"id":"2d01d9688ecbe4da","type":"text","text":"Green arrows are chat arrows. They can be used to build custom chatbots within obsidian using Cannoli.\\n\\nTry this by moving to a note, then running this cannoli using the \\"4. Chat arrows\\" command.","x":-277,"y":-440,"width":427,"height":180},{"id":"6ff1bc87ce822f42","x":-890,"y":489,"width":403,"height":218,"type":"text","text":"You can limit the number of messages parsed from a note by adding a number to the label.\\n\\nJust a number will limit the number of messages, and adding a \\"#\\" to the beginning of the label will limit based on an approximation of tokens. "},{"id":"2213c3caec2e3835","x":-800,"y":804,"width":315,"height":96,"type":"text","text":"The example on the left will send the most recent two messages from the note"},{"id":"fd4602caf5adb9bc","x":560,"y":508,"width":440,"height":90,"type":"text","text":"This chat arrow will send messages not exceeding the estimated token limit (but at least 1 message)"}],"edges":[{"id":"dddd3b587c8b7340","fromNode":"1097b1b80a3abe81","fromSide":"bottom","toNode":"09ce49517baf7eda","toSide":"top","color":"4"},{"id":"847946cb0fc14d7a","fromNode":"09ce49517baf7eda","fromSide":"bottom","toNode":"b90c7fbfa70e4300","toSide":"top","color":"4"},{"id":"8cc7de72b0881d19","fromNode":"ef3cdc2a117f9156","fromSide":"bottom","toNode":"82ba7993840f1760","toSide":"top","color":"4","label":"2"},{"id":"a738da5d15aa4bd8","fromNode":"82ba7993840f1760","fromSide":"bottom","toNode":"9a309223d6ce3931","toSide":"top","color":"2"},{"id":"b2376898a9f7d1f1","fromNode":"09a9d8dd0741d74b","fromSide":"bottom","toNode":"f2d8da368e1c51b6","toSide":"top","color":"2"},{"id":"9406dd17d5c41032","fromNode":"cd757b7484ffd798","fromSide":"bottom","toNode":"09a9d8dd0741d74b","toSide":"top","color":"4","label":"#500"}]}'
    }
  ],
  "3. Special nodes": [
    {
      name: "1. Floating nodes.canvas",
      content: `{"nodes":[{"type":"group","id":"6221f4693ddb3417","x":-320,"y":-80,"width":600,"height":460,"label":"Floating nodes"},{"type":"text","text":"Use a specific format on a floating node (no attached arrows) to create a global variable. You can read and write to this variable anywhere in the cannoli.","id":"9650a6926008b16f","x":-234,"y":-259,"width":414,"height":119},{"type":"text","text":"Now just write the new version by itself in your next response.","id":"867aca6f08aff01f","x":-1,"y":124,"width":250,"height":116},{"type":"text","text":"Please critique and rewrite this email to be a bit more apologetic:\\n{{[Email Draft]}}","id":"848648ac1ab74998","x":-14,"y":-60,"width":274,"height":120},{"type":"text","text":"{{[Email Draft]}}","id":"5246f4d07c4012a8","x":-1,"y":300,"width":250,"height":60,"color":"6"},{"type":"text","text":"In this example we reference and write to a floating node.","id":"38e2ac4e746d3f44","x":-580,"y":-30,"width":250,"height":90},{"type":"text","text":"When a floating node's first line is in single square brackets, it can be accessed as a variable.","id":"ff6cf4c87583cf77","x":-580,"y":111,"width":250,"height":129},{"type":"text","text":"You can reference floating node variables the same way you'd reference normal variables, but with the addition of single square brackets.","id":"80a63e1ff8700f60","x":300,"y":-40,"width":340,"height":120},{"type":"text","text":"This is an example of a Reference Node. When a content node is just a floating node reference or note reference wrapped in  double curly braces, you can write to the referenced location instead of the node itself.","id":"f0466f473408290b","x":300,"y":240,"width":516,"height":127},{"type":"text","text":"[Email Draft]\\nLet me get back to you on that","id":"329298ec10140a51","x":-300,"y":75,"width":250,"height":99}],"edges":[{"id":"f33f402d10538f79","fromNode":"848648ac1ab74998","fromSide":"bottom","toNode":"867aca6f08aff01f","toSide":"top"},{"id":"bfad0ddbfa29f18f","fromNode":"867aca6f08aff01f","fromSide":"bottom","toNode":"5246f4d07c4012a8","toSide":"top"}]}`
    },
    {
      name: "2. Action nodes.canvas",
      content: '{"nodes":[{"type":"group","id":"bde9e8c9838b15f7","x":-540,"y":260,"width":920,"height":820,"label":"Template example"},{"type":"group","id":"57121fc775e40f08","x":-480,"y":-140,"width":720,"height":304,"label":"Action node"},{"type":"text","text":"Write me a text with my todo items for tomorrow. Here are my notes:\\n{{[[TODO]]}}","id":"644e75c14fbf0f66","x":-452,"y":-120,"width":291,"height":130},{"type":"text","text":"You can set up action node templates in two ways.\\n\\n1. Adding them in the plugin settings (click + Template)\\n2. Creating a floating node with the template as a JSON object","id":"d7c2f23ed59d226e","x":-863,"y":-120,"width":329,"height":280},{"type":"text","text":"Random Chuck Norris Joke","id":"26a3b80a6af9c744","x":-80,"y":-120,"width":250,"height":60,"color":"2"},{"type":"text","text":"Translate this joke into latin and remove the json","id":"89cfe3ad39ea9129","x":-80,"y":-20,"width":250,"height":60,"color":"0"},{"type":"text","text":"","id":"f0588ef3506e99e9","x":-80,"y":70,"width":250,"height":60,"color":"6"},{"type":"text","text":"Text me","id":"a4500d915425b8f6","x":-431,"y":70,"width":250,"height":60,"color":"2"},{"type":"text","text":"Simply reference a template using its name in the action node.","id":"ef226520ee26b04e","x":260,"y":-40,"width":362,"height":80},{"type":"text","text":"Orange nodes are action nodes. You can use them to make http calls with content from the cannoli.","id":"60bd8cc6ffcdd82b","x":-280,"y":-320,"width":291,"height":123},{"type":"text","text":"In this example, the body template requires two variables, \\"subject\\" and \\"content\\". You can provide these variables the way you usually provide variables for call nodes.","id":"1276a3e56b64ebfc","x":400,"y":582,"width":448,"height":136},{"type":"text","text":"[Email me]\\n```json\\n{\\n  \\"url\\": \\"https://api.sendgrid.com/v3/mail/send\\",\\n  \\"method\\": \\"POST\\",\\n  \\"headers\\": {\\n    \\"Content-Type\\": \\"application/json\\",\\n    \\"Authorization\\": \\"Bearer 1234\\"\\n  },\\n  \\"bodyTemplate\\": {\\n    \\"personalizations\\": [\\n      {\\n        \\"to\\": [\\n          {\\n            \\"email\\": \\"cannoli@cannoli.com\\"\\n          }\\n        ]\\n      }\\n    ],\\n    \\"from\\": {\\n      \\"email\\": \\"cannoli@cannoli.com\\"\\n    },\\n    \\"subject\\": \\"{{subject}}\\",\\n    \\"content\\": [\\n      {\\n        \\"type\\": \\"text/plain\\",\\n        \\"value\\": \\"{{content}}\\"\\n      }\\n    ]\\n  }\\n}\\n```","id":"00e28f79ba0da98b","x":-500,"y":300,"width":440,"height":740},{"type":"text","text":"Write me an email summarizing my notes from this meeting:\\n{{[[Meeting Notes]]}}","id":"a48a862d95ca71ae","x":-40,"y":520,"width":291,"height":130},{"type":"text","text":"Email me","id":"1d13ff952b032937","x":-19,"y":760,"width":250,"height":60,"color":"2"},{"type":"text","text":"Body Templates:\\n\\n- You can predefine what the body of the http request will look like using a body template.\\n- Name variable references using the format {{variable}}. You can use this to inject content from the cannoli in specific ways.\\n- If there is no body template, the body will just be whatever is written to the action node.","id":"f44dec64c8fe0af2","x":-1020,"y":700,"width":458,"height":277},{"type":"text","text":"You can write action node templates in JSON like this. (The JSON code block is optional)\\n\\nThese fields are required:\\n\\n- url\\n- method\\n\\nThese fields are optional:\\n\\n- headers\\n- bodyTemplate","id":"0967ce0429d322cc","x":-1020,"y":300,"width":458,"height":340}],"edges":[{"id":"964c0c5be9b3a97a","fromNode":"644e75c14fbf0f66","fromSide":"bottom","toNode":"a4500d915425b8f6","toSide":"top"},{"id":"a80a16dedbed00a1","fromNode":"26a3b80a6af9c744","fromSide":"bottom","toNode":"89cfe3ad39ea9129","toSide":"top"},{"id":"dad771d1fff98094","fromNode":"89cfe3ad39ea9129","fromSide":"bottom","toNode":"f0588ef3506e99e9","toSide":"top"},{"id":"bb08ec4cc1aba258","fromNode":"a48a862d95ca71ae","fromSide":"bottom","toNode":"1d13ff952b032937","toSide":"top","color":"6","label":"subject"},{"id":"4965c2f949fd6be0","fromNode":"a48a862d95ca71ae","fromSide":"right","toNode":"1d13ff952b032937","toSide":"right","color":"6","label":"content"}]}'
    },
    {
      name: "3. Formatter nodes.canvas",
      content: '{"nodes":[{"type":"group","id":"94f5f94475efad52","x":-242,"y":-100,"width":512,"height":635,"label":"Formatter nodes"},{"type":"text","text":"Respond with the name of a nosy villager character","id":"e2163e206cbda905","x":-200,"y":-80,"width":250,"height":60},{"type":"text","text":"","id":"b9b423ce99fb31c9","x":-217,"y":360,"width":284,"height":155,"color":"6"},{"type":"text","text":"A content node wrapped in double double quotes (\\"\\") is a formatter node. They will not be overwritten.","id":"0be55ec8c78cd264","x":-500,"y":201,"width":250,"height":119},{"type":"text","text":"\\"\\"Name: {{name}}\\nLines:\\n{{lines}}\\"\\"","id":"4f1b8e3bd87e5bd8","x":-222,"y":160,"width":294,"height":140,"color":"6"},{"type":"text","text":"Formatter nodes allow you to work with variables the same way you do with call nodes, but without making an LLM call.","id":"b6560aee19ea758c","x":-180,"y":-260,"width":394,"height":113},{"type":"text","text":"You can use the output of formatter nodes the same way you use call nodes.","id":"897ca9e72f35add4","x":-500,"y":385,"width":250,"height":105},{"type":"text","text":"Now write a list of 5 lines they might say.","id":"7a909145058b7691","x":0,"y":40,"width":250,"height":60}],"edges":[{"id":"3ba3954eb0260bb0","fromNode":"e2163e206cbda905","fromSide":"bottom","toNode":"7a909145058b7691","toSide":"top"},{"id":"be08a31884ecc768","fromNode":"e2163e206cbda905","fromSide":"bottom","toNode":"4f1b8e3bd87e5bd8","toSide":"top","label":"name"},{"id":"2f201d9220f6ef3f","fromNode":"7a909145058b7691","fromSide":"bottom","toNode":"4f1b8e3bd87e5bd8","toSide":"top","label":"lines"},{"id":"f590014afea4fcd1","fromNode":"4f1b8e3bd87e5bd8","fromSide":"bottom","toNode":"b9b423ce99fb31c9","toSide":"top"}]}'
    },
    {
      name: "4. Reference nodes.canvas",
      content: '{"nodes":[{"type":"group","id":"546578b6fae29490","x":-420,"y":-160,"width":580,"height":640,"label":"Reference nodes"},{"id":"8d414d7be725ce11","type":"group","x":-420,"y":880,"width":610,"height":259,"label":"Getting properties"},{"id":"8fd4e3f6e22304ba","type":"group","x":-420,"y":560,"width":290,"height":259,"label":"Getting note name"},{"id":"8c0fb44530075f7d","type":"group","x":-420,"y":1200,"width":290,"height":259,"label":"Getting note path"},{"type":"text","text":"{{[Current state]}}","id":"079588e3f7e0afa0","x":-393,"y":203,"width":250,"height":60,"color":"6"},{"type":"text","text":"Reference nodes can reference floating nodes or notes from your vault.","id":"a8346a9d96a737bb","x":-692,"y":238,"width":262,"height":114},{"type":"text","text":"Reference nodes are content nodes surrounded by double curly braces.","id":"a9ea85b101bc8776","x":-686,"y":-149,"width":250,"height":129},{"type":"text","text":"You can write or read from them the same way you use normal content nodes.","id":"be5c114d263a0107","x":-686,"y":66,"width":250,"height":137},{"type":"text","text":"Write a poem about walking","id":"fba8c017a84a0a74","x":-380,"y":-124,"width":250,"height":60,"color":"0"},{"type":"text","text":"{{[[Walking Poem]]}}","id":"e8e998b3d784e3a1","x":-380,"y":6,"width":250,"height":60,"color":"6"},{"type":"text","text":"Reference nodes can be used to write to and read from notes in your vault or floating nodes on the cannoli.","id":"28c071d10dfda17f","x":-333,"y":-340,"width":379,"height":122},{"type":"text","text":"[Current state]\\nNot much going on","id":"e08885cd2f146f7d","x":-113,"y":203,"width":250,"height":92},{"id":"344bb3da359269a4","type":"text","text":"","x":-100,"y":327,"width":237,"height":113,"color":"6"},{"type":"text","text":"Does this change our plan at all:\\n{{a}}","id":"e9768515f6295d9b","x":-393,"y":333,"width":250,"height":100,"color":"0"},{"id":"963eacfd11f92b34","type":"text","text":"{{[[Meeting Notes]]}}","x":-400,"y":580,"width":250,"height":60,"color":"6"},{"id":"ef10f47160ceb92a","type":"text","text":"","x":-400,"y":739,"width":250,"height":60,"color":"6"},{"id":"f85bdd621bacd536","type":"text","text":"If a variable arrow coming from a reference node starts with a square bracket, it will extract the link for the reference.\\n\\nThis is uses in cases when you dynamically create nodes and need to get their link reliably.","x":-763,"y":580,"width":318,"height":239},{"id":"da10ade6ef9ec7fb","type":"text","text":"{{[[Meeting Notes]]}}","x":-400,"y":900,"width":250,"height":60,"color":"6"},{"id":"d0e83b31dc2a1576","type":"text","text":"{{[[Meeting Notes]]}}","x":-90,"y":900,"width":250,"height":60,"color":"6"},{"id":"1566407420c6d37d","type":"text","text":"","x":-400,"y":1059,"width":250,"height":60,"color":"6"},{"id":"68e42dd6d4721f26","type":"text","text":"","x":-90,"y":1059,"width":250,"height":60,"color":"6"},{"id":"28a0281c87a0c588","type":"text","text":"{{[[Meeting Notes]]}}","x":-400,"y":1220,"width":250,"height":60,"color":"6"},{"id":"babacacceece0d0f","type":"text","text":"","x":-400,"y":1379,"width":250,"height":60,"color":"6"},{"id":"bad9bf674fca2bfa","type":"text","text":"You can use arrows that start with \\":\\" to retrieve the associated property of the same name from a note.\\n\\nIf there is nothing on the arrow other than \\":\\", all properties will be retrieved. ","x":-763,"y":900,"width":318,"height":239},{"id":"b6b1e156ad3548a2","type":"text","text":"You can use arrows that start with \\"/\\" to retrieve the path of a reference node.\\n\\nThis could be useful for creating notes in the same folder as dynamically selected notes.","x":-763,"y":1220,"width":318,"height":219}],"edges":[{"id":"bc3f3aa5abc3914d","fromNode":"fba8c017a84a0a74","fromSide":"bottom","toNode":"e8e998b3d784e3a1","toSide":"top"},{"id":"c98efd6bf2dff5d4","fromNode":"079588e3f7e0afa0","fromSide":"bottom","toNode":"e9768515f6295d9b","toSide":"top","label":"a"},{"id":"20b93bd61e36c19f","fromNode":"963eacfd11f92b34","fromSide":"bottom","toNode":"ef10f47160ceb92a","toSide":"top","label":"["},{"id":"d1ab9632f705d309","fromNode":"e9768515f6295d9b","fromSide":"right","toNode":"344bb3da359269a4","toSide":"left","color":"2"},{"id":"4320417bc6736dd9","fromNode":"da10ade6ef9ec7fb","fromSide":"bottom","toNode":"1566407420c6d37d","toSide":"top","label":":Date"},{"id":"e56ac04c2a7ef6da","fromNode":"d0e83b31dc2a1576","fromSide":"bottom","toNode":"68e42dd6d4721f26","toSide":"top","label":":"},{"id":"06d6a4450c69c049","fromNode":"28a0281c87a0c588","fromSide":"bottom","toNode":"babacacceece0d0f","toSide":"top","label":"/"}]}'
    }
  ],
  "4. Vault interaction": [
    {
      name: "1. Referencing notes.canvas",
      content: `{"nodes":[{"type":"group","id":"1e30c5b622c33707","x":-700,"y":-160,"width":600,"height":500,"label":"Reference nodes"},{"type":"group","id":"34ab67ca730bb363","x":-700,"y":420,"width":600,"height":500,"label":"Extraction modifiers"},{"type":"group","id":"4b47baa584657fc0","x":-700,"y":-620,"width":650,"height":360,"label":"Notes as variables"},{"id":"3c55aea3ab7679cf","type":"group","x":-690,"y":1680,"width":610,"height":259,"label":"Getting properties"},{"id":"71f82d60459605e9","type":"group","x":-690,"y":1000,"width":290,"height":290,"label":"Special \\"NOTE\\" reference"},{"id":"bc6196ed2a59141c","type":"group","x":-690,"y":1360,"width":290,"height":259,"label":"Getting note names"},{"id":"f5c0436b8aa42d7f","type":"group","x":-690,"y":2000,"width":290,"height":259,"label":"Getting note path"},{"type":"text","text":"Check this out:\\n{{[[Lemons for Cleaning]]}}","id":"24fc10789416284c","x":-680,"y":-600,"width":250,"height":60},{"type":"text","text":"What was in that note?","id":"e62b59877d19a53b","x":-680,"y":-490,"width":250,"height":50},{"type":"text","text":"","id":"62447884955fc816","x":-409,"y":-560,"width":349,"height":280,"color":"6"},{"type":"text","text":"You can reference notes in Cannolis to give LLMs up-to-date context conveniently.","id":"305dbf844cee4b22","x":-562,"y":-780,"width":328,"height":102},{"type":"text","text":"To show the LLM the content of a note, simply wrap a note link in curly braces, just as you would a variable.","id":"9ae16a6025e83401","x":-1060,"y":-521,"width":345,"height":113},{"type":"file","file":"Cannoli College/Example notes/Apple Trees.md","text":"{{[[Apple Trees]]}}","id":"b7597d6f39e7acc9","x":-690,"y":-120,"width":283,"height":145},{"type":"text","text":"What's the note above about","id":"8039b20f5e260110","x":-673,"y":80,"width":250,"height":80},{"type":"text","text":"What's this about:\\n{{a}}","id":"dec28b770c6e0601","x":-359,"y":80,"width":250,"height":80},{"type":"text","text":"","id":"37c33e8f19a09beb","x":-680,"y":-380,"width":250,"height":100,"color":"6"},{"type":"text","text":"You can also pull the content of notes with arrows leaving Obsidian's built-in file cards.","id":"7563d53b40bf5f1a","x":-986,"y":-101,"width":271,"height":126},{"type":"text","text":"The same effect can be achieved with a reference node, using this double curly brace notation in a content node.","id":"7486aafd14a866f8","x":-80,"y":-103,"width":340,"height":111},{"type":"text","text":"{{[[Lemons for Cleaning]]}}","id":"aa6a67a2ff0f2fe8","x":-359,"y":-77,"width":250,"height":60,"color":"6"},{"type":"text","text":"","id":"a96e14fbb7d1265f","x":-673,"y":200,"width":250,"height":120,"color":"6"},{"type":"text","text":"","id":"7f19194be69549ec","x":-359,"y":200,"width":250,"height":120,"color":"6"},{"id":"e7990bd20a1a3f11","type":"text","text":"{{NOTE}}","x":-670,"y":1020,"width":250,"height":60},{"id":"da19d9eee04a6946","type":"text","text":"This reference node will always correspond to the active note when the cannoli was started.\\n\\nYou can use this syntax to build chatbots (see [[4. Chat arrows.cno.canvas|4. Chat arrows.cno]]) or cannolis that process the content of the active note somehow.","x":-1039,"y":1010,"width":324,"height":260},{"id":"dd06bd8ffd8959c3","type":"text","text":"","x":-670,"y":1140,"width":250,"height":130,"color":"6"},{"type":"text","text":"You can change how notes are extracted or edited using symbols after the note within a reference.\\n\\nThese modifiers will override the related settings you chose in the cannoli settings.","id":"f98df3d186b6b8b3","x":-1080,"y":410,"width":365,"height":205},{"id":"21a132196d1026bf","type":"text","text":"To add the filename of a note as a header, reference it like this:\\n{{[[Note]]#}}\\n\\nIf your default setting is to add the filename header, you can remove it like this:\\n{{[[Note]]!#}}","x":-1074,"y":660,"width":354,"height":245},{"type":"text","text":"{{[[Meeting Notes]]^}}","id":"10439db683a6c0a7","x":-368,"y":473,"width":250,"height":60,"color":"6"},{"id":"0856fc4c98e0e01c","type":"text","text":"To include the properties (YAML frontmatter) in the note, reference it like this:\\n{{[[Note]]^}}\\n\\nIf your default setting is to include the properties, you can remove them like this:\\n{{[[Note]]!^}}\\n\\nIf you are editing a note, this modifier will also change if the edit can affect the existing properties. This is useful if you don't want to overwrite properties when you edit a note.","x":-80,"y":408,"width":420,"height":342},{"id":"8352e64802f9ff93","type":"text","text":"You can add multiple modifiers in a single reference:\\n{{[[Note]]^!#}}","x":-80,"y":780,"width":398,"height":120},{"id":"b63aa69459ed0e33","type":"text","text":"{{[[Meeting Notes]]}}","x":-670,"y":1380,"width":250,"height":60,"color":"6"},{"id":"d19cad0060fcb71c","type":"text","text":"","x":-670,"y":1539,"width":250,"height":60,"color":"6"},{"id":"9aff2c48988f7fdf","type":"text","text":"If a variable arrow coming from a reference node starts with a square bracket, it will extract the link for the reference.\\n\\nThis is uses in cases when you dynamically create nodes and need to get their link reliably.","x":-1033,"y":1380,"width":318,"height":239},{"id":"d399962128a18b2e","type":"text","text":"","x":-680,"y":615,"width":268,"height":277,"color":"6"},{"id":"919f3852d5538bac","type":"text","text":"","x":-377,"y":615,"width":268,"height":277,"color":"6"},{"type":"text","text":"{{[[Meeting Notes]]#}}","id":"30afb34c1019f5df","x":-670,"y":473,"width":250,"height":60,"color":"6"},{"id":"9967b60050a55863","type":"text","text":"{{[[Meeting Notes]]}}","x":-670,"y":1700,"width":250,"height":60,"color":"6"},{"id":"570d87dc498def43","type":"text","text":"","x":-670,"y":1859,"width":250,"height":60,"color":"6"},{"id":"94c9f6ee12de2723","type":"text","text":"You can use arrows that start with \\":\\" to retrieve the associated property of the same name from a note.\\n\\nIf there is nothing on the arrow other than \\":\\", all properties will be retrieved. ","x":-1033,"y":1700,"width":318,"height":239},{"id":"382cdbdf89daa53c","type":"text","text":"{{[[Meeting Notes]]}}","x":-360,"y":1700,"width":250,"height":60,"color":"6"},{"id":"386367aa8acf2917","type":"text","text":"","x":-360,"y":1859,"width":250,"height":60,"color":"6"},{"id":"47f1774a10a6de98","type":"text","text":"{{[[Meeting Notes]]}}","x":-670,"y":2020,"width":250,"height":60,"color":"6"},{"id":"09ec11f71f736c5a","type":"text","text":"","x":-670,"y":2179,"width":250,"height":60,"color":"6"},{"id":"82df68e8b67c09c8","type":"text","text":"You can use arrows that start with \\"/\\" to retrieve the path of a reference node.\\n\\nThis could be useful for creating notes in the same folder as dynamically selected notes.","x":-1033,"y":2020,"width":318,"height":219}],"edges":[{"id":"7ebbdaba21c78245","fromNode":"24fc10789416284c","fromSide":"right","toNode":"62447884955fc816","toSide":"top","color":"2"},{"id":"ee4e6166d0ffe43d","fromNode":"24fc10789416284c","fromSide":"bottom","toNode":"e62b59877d19a53b","toSide":"top"},{"id":"063d6d8d083b2666","fromNode":"b7597d6f39e7acc9","fromSide":"bottom","toNode":"8039b20f5e260110","toSide":"top"},{"id":"9bcad28d8d703638","fromNode":"aa6a67a2ff0f2fe8","fromSide":"bottom","toNode":"dec28b770c6e0601","toSide":"top","label":"a"},{"id":"ba5e154b30f8168f","fromNode":"e62b59877d19a53b","fromSide":"bottom","toNode":"37c33e8f19a09beb","toSide":"top"},{"id":"6e838ae4192a0925","fromNode":"8039b20f5e260110","fromSide":"bottom","toNode":"a96e14fbb7d1265f","toSide":"top"},{"id":"7f3f25c31ae38f6d","fromNode":"dec28b770c6e0601","fromSide":"bottom","toNode":"7f19194be69549ec","toSide":"top"},{"id":"8af2e272382f3038","fromNode":"e7990bd20a1a3f11","fromSide":"bottom","toNode":"dd06bd8ffd8959c3","toSide":"top"},{"id":"aba263db1eb0f4b6","fromNode":"9967b60050a55863","fromSide":"bottom","toNode":"570d87dc498def43","toSide":"top","label":":Date"},{"id":"f0e0c3d61fe7aca3","fromNode":"30afb34c1019f5df","fromSide":"bottom","toNode":"d399962128a18b2e","toSide":"top"},{"id":"e137cb2b47fff78e","fromNode":"10439db683a6c0a7","fromSide":"bottom","toNode":"919f3852d5538bac","toSide":"top"},{"id":"7919954c7360c103","fromNode":"b63aa69459ed0e33","fromSide":"bottom","toNode":"d19cad0060fcb71c","toSide":"top","label":"["},{"id":"a149899b3a0f51b7","fromNode":"47f1774a10a6de98","fromSide":"bottom","toNode":"09ec11f71f736c5a","toSide":"top","label":"/"},{"id":"1bb84d00af5d18f5","fromNode":"382cdbdf89daa53c","fromSide":"bottom","toNode":"386367aa8acf2917","toSide":"top","label":":"}]}`
    },
    {
      name: "2. Writing to notes.canvas",
      content: `{"nodes":[{"type":"group","id":"a81f6864d57513f0","x":-335,"y":300,"width":755,"height":620,"label":"Tips"},{"type":"group","id":"92f439736587539d","x":-335,"y":-760,"width":615,"height":477,"label":"Reference nodes"},{"id":"50c183ba68857287","type":"group","x":-335,"y":1000,"width":610,"height":259,"label":"Editing properties"},{"type":"group","id":"255a410c19a12e56","x":-335,"y":-160,"width":355,"height":328,"label":"Protecting properties"},{"type":"text","text":"You can write to notes using file cards or the reference node format shown below.","id":"d9b027f149b4da0f","x":-140,"y":-942,"width":253,"height":122},{"type":"text","text":"Write a short article about using lemons for cleaning. It should have the title \\"Lemons for Cleaning\\" and use proper markdown.","id":"e19b655090530949","x":-312,"y":-740,"width":255,"height":150},{"type":"text","text":"Write a short article about using lemons for cleaning. It should have the title \\"Lemons for Cleaning\\" and use proper markdown.","id":"1de6b113e5ad75c5","x":8,"y":-740,"width":250,"height":150},{"type":"file","file":"Cannoli College/Example notes/Lemons for Cleaning.md","text":"{{[[Lemons for Cleaning]]}}","id":"d6552cf2b811cb0a","x":-315,"y":-540,"width":261,"height":237},{"type":"text","text":"You can write to a note the same way you'd write to a normal content node, from call nodes or other content nodes.","id":"fe1f2c35a7426056","x":-640,"y":-622,"width":280,"height":120},{"type":"text","text":"{{[[Lemons for Cleaning]]}}","id":"2160d3369fea2bcb","x":8,"y":-451,"width":250,"height":60,"color":"6"},{"type":"text","text":"Write a sample meeting minutes","id":"cc3989fddfc7607b","x":-297,"y":-134,"width":250,"height":80},{"type":"text","text":"Utilize multiple chat messages to get a clean written response. You can even use a more expensive model to generate the article, then use a less expensive one to copy the final product to the note.","id":"98deb4f5f13687c5","x":-800,"y":470,"width":440,"height":145},{"type":"text","text":"Outline and write a short article about growing apple trees.","id":"63db7ba6f5cb3524","x":-312,"y":320,"width":250,"height":100},{"type":"text","text":"Write a short poem about walking.","id":"9de84ebf983156f8","x":8,"y":320,"width":250,"height":100},{"type":"file","file":"Cannoli College/Example notes/Apple Trees.md","text":"{{[[Apple Trees]]}}","id":"0561c9ae1669460f","x":-315,"y":715,"width":255,"height":189},{"type":"text","text":"","id":"9de536515698d256","x":220,"y":618,"width":182,"height":62,"color":"6"},{"type":"text","text":"Field arrows can help get good formatting for notes. Use \\"content\\" and \\"title\\" field names to keep the LLM from writing the title of the note into the content.","id":"5943bd16d1a71072","x":440,"y":506,"width":357,"height":119},{"type":"text","text":"Ok, now respond with just the article\\n\\nThere should be nothing in your response other than the article","id":"94567e5a2b31c42b","x":-315,"y":475,"width":255,"height":180},{"type":"text","text":"You can change how notes are extracted or edited using symbols after the note within a reference.\\n\\nThese modifiers will override the related settings you chose in the cannoli settings.","id":"bffb0679a38e68b5","x":-720,"y":-134,"width":365,"height":205},{"id":"9fa03f1308317478","type":"text","text":"To allow the edit to overwrite the properties (YAML frontmatter) in the note, reference it like this:\\n{{[[Note]]^}}\\n\\nIf your default setting is to include (overwrite) the properties, you can remove them like this:\\n{{[[Note]]!^}}","x":48,"y":-122,"width":420,"height":229},{"type":"text","text":"{{[[Lemons for Cleaning]]!^}}","id":"6c3aaf24c1410da5","x":-309,"y":77,"width":274,"height":60,"color":"6"},{"type":"file","file":"Cannoli College/Example notes/Walking Poem.md","text":"{{[[Apple Trees]]}}","id":"5e54d6df61248d37","x":8,"y":715,"width":255,"height":189},{"id":"fe4f45ec55ab88f8","type":"text","text":"You can use arrows that start with \\":\\" to edit the property in the arrow label.\\n\\nThis also works for list format properties.","x":-678,"y":1020,"width":318,"height":189},{"id":"ae32c84e56f650cb","type":"text","text":"{{[[Meeting Notes]]}}","x":-310,"y":1179,"width":250,"height":60,"color":"6"},{"id":"b58f063da822b869","type":"text","text":"Tuesday","x":-310,"y":1020,"width":250,"height":60,"color":"6"},{"id":"d283ed9e9d24b01d","type":"text","text":"{{[[Meeting Notes]]}}","x":0,"y":1179,"width":250,"height":60,"color":"6"},{"id":"f82f1adc99fcc4db","type":"text","text":"- jim\\n- mary","x":0,"y":1020,"width":250,"height":80,"color":"6"}],"edges":[{"id":"32c1cb193a6bfc19","fromNode":"e19b655090530949","fromSide":"bottom","toNode":"d6552cf2b811cb0a","toSide":"top"},{"id":"e339725c61ba4f0b","fromNode":"1de6b113e5ad75c5","fromSide":"bottom","toNode":"2160d3369fea2bcb","toSide":"top"},{"id":"741c9e0b211241a2","fromNode":"94567e5a2b31c42b","fromSide":"bottom","toNode":"0561c9ae1669460f","toSide":"top"},{"id":"38d8c5cd09414fe8","fromNode":"9de84ebf983156f8","fromSide":"bottom","toNode":"5e54d6df61248d37","toSide":"top","color":"6","label":"content"},{"id":"6e207e77a539fbd3","fromNode":"9de84ebf983156f8","fromSide":"bottom","toNode":"9de536515698d256","toSide":"top","color":"6","label":"title"},{"id":"e7cd177b0fe4bf6b","fromNode":"63db7ba6f5cb3524","fromSide":"bottom","toNode":"94567e5a2b31c42b","toSide":"top"},{"id":"996659a79f50e2da","fromNode":"cc3989fddfc7607b","fromSide":"bottom","toNode":"6c3aaf24c1410da5","toSide":"top"},{"id":"790403f81a184f3b","fromNode":"b58f063da822b869","fromSide":"bottom","toNode":"ae32c84e56f650cb","toSide":"top","label":":weekday"},{"id":"503b5af7f363b512","fromNode":"f82f1adc99fcc4db","fromSide":"bottom","toNode":"d283ed9e9d24b01d","toSide":"top","label":":tags"}]}`
    },
    {
      name: "3. Dynamic note references.canvas",
      content: `{"nodes":[{"type":"group","id":"3884a37115998334","x":-200,"y":1160,"width":520,"height":760,"label":"Dynamic reference nodes"},{"type":"group","id":"1d4638cc848ce883","x":-160,"y":460,"width":460,"height":575,"label":"Ensuring proper note names"},{"type":"group","id":"190c7fe39136a4e6","x":-175,"y":-400,"width":321,"height":575,"label":"Note names as variables"},{"type":"text","text":"What's this about:\\n{{@note}}","id":"4e5095e59d3b1f75","x":-140,"y":-100,"width":250,"height":58},{"type":"text","text":"","id":"78a31a6b0db6e00a","x":-155,"y":40,"width":281,"height":115,"color":"6"},{"type":"text","text":"An \\"@\\" symbol in front of a variable reference will have the node attempt to extract the content of the note with that name.","id":"8dc52a792fef349a","x":-460,"y":-146,"width":275,"height":150},{"type":"text","text":"Respond with the name of one of these notes without square brackets:\\n[[Apple Trees]],\\n[[Lemons for Cleaning]]","id":"71fc4d9bcf7e5cef","x":-140,"y":-380,"width":250,"height":160},{"type":"text","text":"In addition to statically referencing notes, you can have the LLM generate note names that you expect to be valid, and reference them in prompts.","id":"aa35fa7b42662498","x":-220,"y":-580,"width":387,"height":120},{"type":"text","text":"Respond with the name of one of these notes:\\n[[Apple Trees]],\\n[[Lemons for Cleaning]]","id":"a563177e81b5c95e","x":-125,"y":480,"width":250,"height":140},{"type":"text","text":"The square bracket signifies that you'd like the LLM to respond with a note name, and Cannoli uses function calling to ensure that the response is only one of the note names present in the prompt.","id":"e2632c0409b0c31e","x":-500,"y":581,"width":335,"height":179},{"type":"text","text":"","id":"39b8926cc93a3400","x":-140,"y":860,"width":281,"height":155,"color":"6"},{"type":"text","text":"You can use this to build Cannolis that interact with your vault in dynamic ways, navigating through it using links.","id":"8c08925cfa290c8a","x":-508,"y":818,"width":343,"height":127},{"type":"text","text":"The same format can also be used for reference nodes.","id":"ff34fc6b7a9db4a4","x":-540,"y":1281,"width":335,"height":79},{"type":"text","text":"In this example, the LLM chooses a note and writes to it.","id":"c185a020e676b84a","x":-548,"y":1500,"width":343,"height":82},{"type":"text","text":"","id":"65d38a62ff03dbfe","x":110,"y":671,"width":175,"height":60,"color":"6"},{"type":"text","text":"Write an article with that title.","id":"d192686ddf19160b","x":40,"y":1430,"width":250,"height":60},{"type":"text","text":"Respond with the name of one of these notes:\\n[[Apple Trees]],\\n[[Lemons for Cleaning]]","id":"6b6b4b634889aad8","x":-165,"y":1180,"width":250,"height":140},{"type":"text","text":"{{@note}}","id":"8a0e100e00bdcaea","x":-165,"y":1582,"width":250,"height":58,"color":"6"},{"type":"text","text":"What's this about:\\n{{@note}}","id":"0db897a7e991783c","x":-125,"y":760,"width":250,"height":58},{"type":"text","text":"","id":"1394a8cbb5db72d9","x":-165,"y":1720,"width":455,"height":180,"color":"6"},{"type":"text","text":"Getting the LLM to properly name notes can be a challenge. You can ensure the response is a valid note name the LLM has seen by using a single square bracket prefix on an arrow label.","id":"8b52c0b7a2e3aa8a","x":-220,"y":240,"width":442,"height":141}],"edges":[{"id":"f0ecaa4ebe5d824b","fromNode":"71fc4d9bcf7e5cef","fromSide":"bottom","toNode":"4e5095e59d3b1f75","toSide":"top","label":"note"},{"id":"303a7695b62bb265","fromNode":"4e5095e59d3b1f75","fromSide":"bottom","toNode":"78a31a6b0db6e00a","toSide":"top","color":"2"},{"id":"cb401d73afd6b5b0","fromNode":"a563177e81b5c95e","fromSide":"bottom","toNode":"0db897a7e991783c","toSide":"top","label":"[note"},{"id":"87145bcd5b0ef58a","fromNode":"0db897a7e991783c","fromSide":"bottom","toNode":"39b8926cc93a3400","toSide":"top","color":"2"},{"id":"d7621f4a15b0b7fb","fromNode":"6b6b4b634889aad8","fromSide":"bottom","toNode":"8a0e100e00bdcaea","toSide":"top","label":"[note"},{"id":"8748f38aca7e3e66","fromNode":"6b6b4b634889aad8","fromSide":"bottom","toNode":"d192686ddf19160b","toSide":"top"},{"id":"6b0d63d0cc50d49a","fromNode":"d192686ddf19160b","fromSide":"bottom","toNode":"8a0e100e00bdcaea","toSide":"top"},{"id":"b2e6acd4ac04fdb5","fromNode":"a563177e81b5c95e","fromSide":"right","toNode":"65d38a62ff03dbfe","toSide":"top","label":"[note"},{"id":"3cbecc9da0226b67","fromNode":"8a0e100e00bdcaea","fromSide":"bottom","toNode":"1394a8cbb5db72d9","toSide":"top"}]}`
    },
    {
      name: "4. Creating notes.canvas",
      content: `{"nodes":[{"id":"4456b948335f3b94","type":"group","x":-334,"y":260,"width":731,"height":518,"label":"Defining path"},{"id":"837ba0cd52636e4c","type":"group","x":-280,"y":-335,"width":677,"height":518,"label":"Creating notes"},{"id":"fc94ad73861dd0b4","type":"text","text":"{{+@articleName}}","x":-40,"y":-146,"width":250,"height":60,"color":"6"},{"id":"375c5de56f45d5e1","type":"text","text":"The Truth About Hula Hoops","x":-260,"y":-296,"width":285,"height":60,"color":"6"},{"id":"679af4d2d1190b6b","type":"text","text":"Write a paragraph about a sinister history of hula hoops","x":85,"y":-315,"width":292,"height":79,"color":"0"},{"id":"bd60374fe51f025d","type":"text","text":"","x":-64,"y":-20,"width":299,"height":183,"color":"6"},{"id":"58140dc2db7bc769","type":"text","text":"You can create a note using a special reference node.\\n\\nAdd a \\"+\\" before the variable in a dynamic reference node, and it will create that note.","x":-660,"y":-236,"width":354,"height":180},{"id":"4c6e2bf4a9959f15","type":"text","text":"Write an overly apologetic email about how we're out of altoids","x":85,"y":280,"width":292,"height":100,"color":"0"},{"id":"6b9ee922dd00451b","type":"text","text":"{{+@title}}","x":-40,"y":449,"width":250,"height":60,"color":"6"},{"id":"8372acb7e244fb15","type":"text","text":"","x":-64,"y":575,"width":299,"height":183,"color":"6"},{"id":"0f4591137e166313","type":"text","text":"No more Altoids","x":-117,"y":280,"width":180,"height":60,"color":"6"},{"id":"b0608205e7a748f6","type":"text","text":"/Cannoli College/4. Vault interaction","x":-306,"y":350,"width":250,"height":60,"color":"6"},{"id":"f3c97367ffc6cce1","x":-700,"y":310,"width":342,"height":180,"type":"text","text":"You can define where the new note will be created using an arrow that starts with \\"/\\".\\n\\nIf it's a valid path, then the note will be created there."},{"id":"dec1b7beb803bffa","x":-608,"y":575,"width":250,"height":60,"type":"text","text":"This example will create a new note in this folder."},{"id":"7a8aaacc8a5f8e49","x":-635,"y":0,"width":329,"height":72,"type":"text","text":"This feature should play nicely with other plugins like templater."}],"edges":[{"id":"87857bf3a2254dec","fromNode":"375c5de56f45d5e1","fromSide":"bottom","toNode":"fc94ad73861dd0b4","toSide":"top","label":"articleName"},{"id":"a49c245f203702e6","fromNode":"679af4d2d1190b6b","fromSide":"bottom","toNode":"fc94ad73861dd0b4","toSide":"top"},{"id":"283a21bf831d34da","fromNode":"fc94ad73861dd0b4","fromSide":"bottom","toNode":"bd60374fe51f025d","toSide":"top"},{"id":"c0aea91c093cd031","fromNode":"6b9ee922dd00451b","fromSide":"bottom","toNode":"8372acb7e244fb15","toSide":"top"},{"id":"7aca371238d9f008","fromNode":"0f4591137e166313","fromSide":"bottom","toNode":"6b9ee922dd00451b","toSide":"top","label":"title"},{"id":"f2ab13710488acaa","fromNode":"4c6e2bf4a9959f15","fromSide":"bottom","toNode":"6b9ee922dd00451b","toSide":"top"},{"id":"f9e1ee261742cf86","fromNode":"b0608205e7a748f6","fromSide":"bottom","toNode":"6b9ee922dd00451b","toSide":"left","label":"/"}]}`
    },
    {
      name: "5. Referencing selections.canvas",
      content: `{"nodes":[{"id":"8c02946171040e71","type":"group","x":30,"y":-145,"width":350,"height":345,"label":"Special \\"SELECTION\\" variable"},{"id":"a0047756f6bf199f","type":"group","x":30,"y":280,"width":350,"height":320,"label":"Replacing selections"},{"id":"28278bc5135af80c","type":"text","text":"Respond with a more concise version of this text:\\n{{SELECTION}}","x":75,"y":-125,"width":250,"height":120},{"id":"9b5312d8361c2f5e","type":"text","text":"","x":75,"y":40,"width":250,"height":130,"color":"6"},{"id":"6f34b064907441fd","type":"text","text":"This works in any workspace where you can select text, including canvas files.\\n\\nTry it on the sentence above.","x":-313,"y":-100,"width":324,"height":140},{"id":"21dc5d31fab5298f","type":"text","text":"You can reference the current selection (the text highlighted by your cursor when you started the cannoli) using the {{SELECTION}} variable","x":11,"y":-360,"width":378,"height":142},{"id":"2deb4b62d41bbfb7","type":"text","text":"Respond with a more concise version of this text:\\n{{SELECTION}}","x":75,"y":300,"width":250,"height":120},{"id":"6e8591393bf5e285","type":"text","text":"You can write to a selection reference node just like a Note reference node. \\n\\nWriting to a {{SELECTION}} node will replace the text if there is a selection, or insert it at the cursor if there isn't.","x":-340,"y":325,"width":351,"height":175},{"id":"880831fc3c8b5e93","type":"text","text":"{{SELECTION}}","x":75,"y":500,"width":250,"height":60,"color":"6"},{"id":"c940877ff5ddd66f","type":"text","text":"Note that if you click away from a selection before the cannoli reaches this node, it will change where the replacement happens, so be wary of long cannolis that use this feature.","x":389,"y":346,"width":404,"height":133}],"edges":[{"id":"ff57adf1f2f08d4d","fromNode":"28278bc5135af80c","fromSide":"bottom","toNode":"9b5312d8361c2f5e","toSide":"top"},{"id":"e6c1d0371468967e","fromNode":"2deb4b62d41bbfb7","fromSide":"bottom","toNode":"880831fc3c8b5e93","toSide":"top"}]}`
    }
  ],
  "5. Groups": [
    {
      name: "1. Basic groups.canvas",
      content: `{"nodes":[{"type":"group","id":"3507f53b8ef19875","x":-400,"y":-280,"width":610,"height":940,"label":"Basic Groups"},{"type":"group","id":"9ea4603066155724","x":-100,"y":-220,"width":290,"height":273,"label":"Group 1"},{"type":"group","id":"9d076987e99ce6a6","x":-100,"y":260,"width":290,"height":240,"label":"Group 2"},{"type":"text","text":"Hey what model are you?","id":"554b1577865f24d4","x":-80,"y":280,"width":250,"height":60},{"type":"text","text":"Actually you don't know that.","id":"35881fd57b1d4269","x":-80,"y":420,"width":250,"height":60},{"type":"text","text":"","id":"fd9b2131408190a4","x":-80,"y":520,"width":250,"height":120,"color":"6"},{"type":"text","text":"gpt-4","id":"e7d78cc1a7a948f8","x":-320,"y":250,"width":105,"height":60,"color":"6"},{"type":"text","text":"Rubiks cube","id":"e83b4c5b2409b738","x":-370,"y":-163,"width":180,"height":57,"color":"6"},{"type":"text","text":"Here we use a basic group to provide all of the member nodes with a variable.","id":"1354395dbba49c59","x":-700,"y":-163,"width":290,"height":93},{"type":"text","text":"Basic groups allow you to conveniently provide variables or change config settings of multiple nodes.\\n\\nFunctionally, its the same as drawing arrows to every node in the group.","id":"cb4e55a56aa20105","x":-320,"y":-500,"width":423,"height":170},{"type":"text","text":"Groups whose label is not an integer are basic groups.","id":"ad8c877c4bdbc784","x":-298,"y":-620,"width":380,"height":94},{"type":"text","text":"You can use {{a}} in this node","id":"3f724ea642f3f39d","x":-80,"y":-200,"width":250,"height":60},{"type":"text","text":"And you can use {{a}} in this node","id":"6b128a864045c0e7","x":-80,"y":-27,"width":250,"height":60},{"type":"text","text":"","id":"b6f9f0b26ae8e68e","x":-80,"y":80,"width":250,"height":100,"color":"6"},{"type":"text","text":"Here we change the model config setting of all the member nodes of a group.","id":"e58e6effa966f52b","x":-728,"y":242,"width":318,"height":98}],"edges":[{"id":"3986f98e5c79c58a","fromNode":"e83b4c5b2409b738","fromSide":"right","toNode":"9ea4603066155724","toSide":"left","label":"a"},{"id":"b54add99d36d3b53","fromNode":"e7d78cc1a7a948f8","fromSide":"right","toNode":"9d076987e99ce6a6","toSide":"left","color":"2","label":"model"},{"id":"3ec08b096671959f","fromNode":"3f724ea642f3f39d","fromSide":"bottom","toNode":"6b128a864045c0e7","toSide":"top"},{"id":"71449d8dc3ac9bac","fromNode":"6b128a864045c0e7","fromSide":"bottom","toNode":"b6f9f0b26ae8e68e","toSide":"top","color":"2"},{"id":"b2ca430257741d71","fromNode":"554b1577865f24d4","fromSide":"bottom","toNode":"35881fd57b1d4269","toSide":"top"},{"id":"948da6eeffd07b7e","fromNode":"35881fd57b1d4269","fromSide":"bottom","toNode":"fd9b2131408190a4","toSide":"top","color":"2"}]}`
    },
    {
      name: "2. Loop groups.canvas",
      content: '{"nodes":[{"type":"group","id":"33e7457728f9ef47","x":-320,"y":-80,"width":820,"height":560,"label":"Nested loop groups"},{"type":"group","id":"0064c11720e6cf20","x":-320,"y":560,"width":820,"height":480,"label":"The loop number variable"},{"type":"group","id":"81cdef3b9de52df9","x":-200,"y":-880,"width":460,"height":680,"label":"Loop groups"},{"type":"group","id":"df42bd1da1866b7f","x":-300,"y":0,"width":330,"height":420,"label":"2"},{"type":"group","id":"2ae53ef6008eeb4e","x":-300,"y":640,"width":360,"height":360,"label":"2"},{"type":"group","id":"986991747df080b2","x":-115,"y":-720,"width":290,"height":260,"label":"3"},{"type":"group","id":"d83bf39a509c67bd","x":-280,"y":150,"width":280,"height":250,"label":"2"},{"type":"group","id":"76b98e9977f73412","x":-280,"y":790,"width":310,"height":190,"label":"2"},{"type":"text","text":"When all the nodes in a loop group are finished, all nodes will reset and the group will restart. \\n\\nIt will loop as many times as are defined in the label, and only the result of the final loop will be sent along the arrows leaving the group.","id":"6e5fbad373215bd8","x":-660,"y":-695,"width":441,"height":170},{"type":"text","text":"Loop groups are colorless groups that have a positive integer in their label.","id":"a408edeafd6bc62f","x":-169,"y":-1040,"width":399,"height":89},{"type":"text","text":"This message will be sent once","id":"2a9251ad533d8576","x":-95,"y":-860,"width":250,"height":60},{"type":"text","text":"This one will be sent 3 times","id":"896ace77fa0c6a7e","x":-95,"y":-700,"width":250,"height":60},{"type":"text","text":"Only the last response will be written to the content node outside the loop.","id":"c6b8d6a1f384022f","x":-95,"y":-610,"width":250,"height":120},{"type":"text","text":"","id":"96f3935e8174877f","x":-95,"y":-400,"width":250,"height":180,"color":"6"},{"type":"text","text":"Nested loop groups will fully reset, meaning in this case the inner group will repeat 4 times.","id":"24835b0cc486957f","x":-690,"y":64,"width":350,"height":106},{"type":"text","text":"This message will be sent 2 times","id":"d09815f95971b8a6","x":-260,"y":20,"width":250,"height":60},{"type":"text","text":"This will be sent 4 times","id":"479bd3009fb464b0","x":-260,"y":170,"width":250,"height":60},{"type":"text","text":"","id":"cdc967d2e777ade5","x":85,"y":-40,"width":395,"height":500,"color":"6"},{"type":"text","text":"Be careful with nested loop groups","id":"bc61ab59035be49d","x":-260,"y":280,"width":250,"height":90},{"type":"text","text":"Logging edges from loop groups will log out what happens on each loop and sub-loop (if its nested)","id":"17c0c46b3378bd79","x":520,"y":120,"width":321,"height":102},{"type":"text","text":"","id":"7b6747a24b1ed36e","x":85,"y":600,"width":395,"height":400,"color":"6"},{"type":"text","text":"Inner loop number: {{#}}\\nOuter loop number: {{##}}","id":"a1e4bbbafcec0850","x":-260,"y":840,"width":270,"height":100},{"id":"f029d4309bd2b1fc","x":-650,"y":665,"width":310,"height":260,"type":"text","text":"You can access the current loop number/iteration of the loop group a node is in using the variable {{#}} or {{##...}}.\\n\\nThe number of \\"#\\"s corresponds to the depth of the loop number you want to see, in the case of nested loops."},{"type":"text","text":"Hello there","id":"4b6e4eac00d4ca2a","x":-250,"y":680,"width":250,"height":60},{"id":"ea53365b1b01a031","x":520,"y":740,"width":356,"height":217,"type":"text","text":"This is useful for processing lists of items using the loop group, as you can tell the LLM to handle a specific item in the list iteratively.\\n\\n(There is a forEach group feature on its way, where this would be handled in parallel)"}],"edges":[{"id":"270794f37f25bb76","fromNode":"c6b8d6a1f384022f","fromSide":"bottom","toNode":"96f3935e8174877f","toSide":"top"},{"id":"fa5fd9941ce413fa","fromNode":"896ace77fa0c6a7e","fromSide":"bottom","toNode":"c6b8d6a1f384022f","toSide":"top"},{"id":"f0286819a9f22127","fromNode":"2a9251ad533d8576","fromSide":"bottom","toNode":"896ace77fa0c6a7e","toSide":"top"},{"id":"007d49590f64ef9d","fromNode":"d09815f95971b8a6","fromSide":"bottom","toNode":"479bd3009fb464b0","toSide":"top"},{"id":"65ef095c89dded80","fromNode":"479bd3009fb464b0","fromSide":"bottom","toNode":"bc61ab59035be49d","toSide":"top"},{"id":"adc29be9103fb02b","fromNode":"bc61ab59035be49d","fromSide":"right","toNode":"cdc967d2e777ade5","toSide":"left","color":"2"},{"id":"734208df80c9a33e","fromNode":"a1e4bbbafcec0850","fromSide":"right","toNode":"7b6747a24b1ed36e","toSide":"left","color":"2"},{"id":"8c921de751762ac3","fromNode":"4b6e4eac00d4ca2a","fromSide":"bottom","toNode":"a1e4bbbafcec0850","toSide":"top"}]}'
    },
    {
      name: "3. Loop group features.canvas",
      content: `{"nodes":[{"type":"group","id":"cd5aefdec24485a6","x":-395,"y":920,"width":1200,"height":1187,"label":"Conditional loop groups"},{"type":"group","id":"b41f5d77d2587137","x":-215,"y":-344,"width":840,"height":948,"label":"Feedback variables"},{"type":"group","id":"a8db6171d1ed7037","x":-375,"y":987,"width":680,"height":1040,"label":"3"},{"type":"group","id":"308eacb6bc673cc4","x":5,"y":-136,"width":290,"height":240,"label":"3"},{"type":"text","text":"Crisp shell, sweet delight, Ricotta whispers within, Sicily's soft night.","id":"8bd344c2d351a946","x":25,"y":-324,"width":250,"height":100,"color":"6"},{"type":"text","text":"If a variable edge is pointing from a group member to the group itself, this variable will be accessible on subsequent loops. (This is an exception to the rule that the Cannoli must be a DAG)","id":"69c0aa7ba528fd7f","x":25,"y":-604,"width":378,"height":187},{"type":"text","text":"Critique this haiku:\\n{{a}}","id":"4522c0d5f13ecbf2","x":25,"y":-104,"width":250,"height":60},{"type":"text","text":"Respond with a rewrite. Nothing else should be in your response.","id":"08d62752b952d1b9","x":25,"y":-14,"width":250,"height":90},{"type":"text","text":"If there are multiple available arrows with the same name, the node will prefer the self-group-pointing one.\\n\\nYou can use this to pre-load variables with an initial version for the first loop, which will be written over in later loops.","id":"1547e2e1c8e36e01","x":-625,"y":-214,"width":390,"height":221},{"type":"text","text":"This is an example of a rewrite loop, where we have the LLM rewrite a piece of content several times and output the final result.","id":"39f5077b01de86bc","x":-618,"y":215,"width":383,"height":121},{"type":"text","text":"","id":"0209622577e4d8e4","x":-195,"y":196,"width":270,"height":205,"color":"6"},{"type":"text","text":"","id":"a8c82e1399aa0667","x":144,"y":217,"width":461,"height":367,"color":"6"},{"type":"text","text":"If a loop group has incoming arrows from within itself, it will only loop if they are all activated.\\n\\nThis means you can use choice arrows to create groups that stop looping based on a decision the LLM makes.","id":"109c6d143c904ac2","x":-40,"y":700,"width":559,"height":153},{"type":"text","text":"Are there any obvious improvements to this article?\\n\\n{{article}}","id":"c9ac27366825fb46","x":-271,"y":1327,"width":283,"height":122},{"type":"text","text":"What would you change?","id":"42e65836e7bc0d2d","x":-254,"y":1540,"width":250,"height":60},{"type":"file","file":"Cannoli College/Example notes/Lemons for Cleaning.md","text":"{{[[Lemons for Cleaning]]}}","id":"9b09ade8a96fdc49","x":-330,"y":1025,"width":400,"height":203},{"type":"text","text":"In this example, we use choice arrows to have the LLM decide whether to edit a note.\\n\\nThe decision to edit it activates a path that points to the group itself, so the group will loop again once it is done.\\n\\nIf that path is rejected, the group will not loop again.","id":"3ae1b1035e633274","x":-814,"y":1228,"width":402,"height":259},{"type":"text","text":"Respond with a rewrite based on your feedback.","id":"92dee3525bb5528a","x":-289,"y":1660,"width":320,"height":100},{"type":"text","text":"","id":"65d12403b1902562","x":120,"y":1328,"width":165,"height":121,"color":"6"},{"type":"text","text":"","id":"c19decb87eb68f4e","x":340,"y":1443,"width":440,"height":535,"color":"6"},{"type":"text","text":"It doesn't matter what the node pointing at the group is, or what kind of arrow. In this case we use a blank arrow to signal that the rewrite path was chosen and add the chat history suppression suffix (~) so we don't continue the conversation in the next loop.","id":"07a8d464729bd7db","x":-800,"y":1864,"width":388,"height":196},{"type":"file","file":"Cannoli College/Example notes/Lemons for Cleaning.md","text":"{{[[Lemons for Cleaning]]}}","id":"a447b4af7f9b59af","x":-329,"y":1820,"width":400,"height":180}],"edges":[{"id":"98bface3c4272939","fromNode":"08d62752b952d1b9","fromSide":"right","toNode":"308eacb6bc673cc4","toSide":"right","label":"a"},{"id":"01117e93ffd16810","fromNode":"8bd344c2d351a946","fromSide":"bottom","toNode":"4522c0d5f13ecbf2","toSide":"top","label":"a"},{"id":"4705bd8c3ac7a1dd","fromNode":"4522c0d5f13ecbf2","fromSide":"bottom","toNode":"08d62752b952d1b9","toSide":"top"},{"id":"09153b08d8afc249","fromNode":"08d62752b952d1b9","fromSide":"bottom","toNode":"0209622577e4d8e4","toSide":"top"},{"id":"d74b679a0e9c5a8e","fromNode":"08d62752b952d1b9","fromSide":"bottom","toNode":"a8c82e1399aa0667","toSide":"top","color":"2"},{"id":"313f7dba1ac082e7","fromNode":"a447b4af7f9b59af","fromSide":"bottom","toNode":"a8db6171d1ed7037","toSide":"bottom","label":"~"},{"id":"ae86725de62f454c","fromNode":"92dee3525bb5528a","fromSide":"right","toNode":"c19decb87eb68f4e","toSide":"left","color":"2"},{"id":"28dd5bf26534621f","fromNode":"9b09ade8a96fdc49","fromSide":"bottom","toNode":"c9ac27366825fb46","toSide":"top","label":"article"},{"id":"cb414a8bed4cab51","fromNode":"c9ac27366825fb46","fromSide":"bottom","toNode":"42e65836e7bc0d2d","toSide":"top","color":"3","label":"yes"},{"id":"8e14d432eb6409d9","fromNode":"c9ac27366825fb46","fromSide":"right","toNode":"65d12403b1902562","toSide":"left","color":"3","label":"no"},{"id":"e151468f90fae46f","fromNode":"42e65836e7bc0d2d","fromSide":"bottom","toNode":"92dee3525bb5528a","toSide":"top"},{"id":"e9279e94dd7a9109","fromNode":"92dee3525bb5528a","fromSide":"bottom","toNode":"a447b4af7f9b59af","toSide":"top"}]}`
    }
  ],
  "Example notes": [
    {
      name: "Apple Trees.md",
      content: "Apple trees, scientifically known as *Malus domestica*, are not just providers of one of the world's most consumed fruits but are also a model of efficiency and adaptability. Originating in Central Asia, these trees have been cultivated for thousands of years and have adapted to a variety of climates, from temperate to sub-tropical. The tree's rootstock can often be grafted to optimize for disease resistance, soil compatibility, or fruit yield, a testament to its remarkable genetic flexibility.\n\nThe life cycle of an apple tree involves a series of well-coordinated biological events. After the cold dormancy of winter, apple trees enter a phase of bud break in the spring, followed by flowering and pollination. Apple trees are usually not self-pollinating and require cross-pollination from another apple tree of a different variety. This ensures genetic diversity, which is crucial for the tree's adaptability and long-term survival. Post-pollination, the tree focuses on fruit development, channeling nutrients and energy into the growing apples.\n\nApple trees also have a profound impact on ecosystems. They offer habitat and food sources for various species, including but not limited to, bees, birds, and small mammals. Their flowers provide nectar for bees, aiding in the process of pollination for not just apple trees but other plants in the ecosystem. Their leaves and bark offer shelter and their fallen fruits are a food source for multiple ground-dwelling organisms. \n\nHowever, it's worth considering the impact of monoculture and industrial farming practices on apple trees. While these methods might increase short-term yield, they can also make the trees more susceptible to diseases and pests by reducing genetic diversity. This opens up a discourse on the need for more sustainable and diversified farming practices. In a world that's increasingly facing the brunt of climate change and biodiversity loss, the apple tree stands as a symbol of both the possibilities and responsibilities that come with cultivation.\n"
    },
    {
      name: "Lemons for Cleaning.md",
      content: "Cleaning your home with lemons is not only effective but also environmentally friendly. Lemons, with their natural disinfecting properties and high citric acid content, can tackle a wide range of cleaning tasks. Here are some detailed tips to maximize the cleaning power of lemons:\n\n1. All-Purpose Cleaner: Create a potent all-purpose cleaner by mixing equal parts lemon juice and water. Lemons contain citric acid, which is effective in killing germs, bacteria, and odors. Squeeze the juice of fresh lemons into a spray bottle, adding an equal amount of water. Shake the bottle well to thoroughly blend the solution. This natural disinfectant is perfect for countertops, sinks, cutting boards, and food containers. To use, simply spray the solution onto the surface and let it sit for a few minutes to allow the citric acid to work its magic. Then, scrub with a sponge or cloth and rinse thoroughly with water.\n\n2. Streak-Free Glass Cleaner: Make your glass surfaces shine with a lemon-based glass cleaner. In a spray bottle, mix equal parts lemon juice and water. The acidity of lemons helps break down dirt and grime, while the natural oils leave a streak-free finish. For tougher stains or spots, add a small amount of vinegar. Shake the bottle well to ensure the ingredients are evenly mixed. To use the cleaner, spray the solution onto the glass surface and use a lint-free cloth or newspaper to wipe it clean. Begin wiping from the top to prevent streaks. Allow the solution to sit on stubborn spots for a few minutes before wiping them away.\n\n3. Eliminating Stains on Faucets and Fixtures: Bid farewell to stains on faucets and fixtures with the natural power of lemons. Cut a lemon in half and rub it directly onto the affected areas, focusing on the stains. The citric acid in lemons effectively breaks down stains while the natural oils give a polished look. After thoroughly rubbing the lemon onto the surface, rinse it with water to remove any residue. Finally, use a dry cloth to polish the faucets and fixtures for a gleaming finish.\n\n4. Rust and Hard Water Stain Remover: Lemons excel at tackling rust and hard water stains. To remove these stubborn stains, dip a cloth or sponge into fresh lemon juice and scrub the affected areas such as faucets, showerheads, or stainless steel appliances. The acidic properties of lemons help dissolve the stains effortlessly. For tougher stains, sprinkle a little salt on the lemon before scrubbing. The salt acts as an abrasive agent. After scrubbing, rinse well with water and dry the surface to prevent further rusting.\n\n5. Natural Air Freshener: Create an inviting and refreshing atmosphere in your home using lemon juice. In a spray bottle, mix lemon juice, water, and a few drops of your favorite essential oil. Lemons have a fresh, citrus scent that naturally eliminates unwanted odors, while the essential oil adds a pleasant fragrance of your choice. Shake the bottle well to ensure the ingredients are properly blended. Spritz this delightful blend around your living spaces to naturally freshen the air. The pleasant, lemony fragrance will replace unwanted odors and create a beautifully scented environment.\n\n6. Polishing and Shining: Lemons can also act as a natural polish for various surfaces. To restore the shine to hardwood furniture, brass, or copper items, cut a lemon in half and dip it into a small amount of salt. Gently rub the lemon onto the surface, allowing the salt and lemon juice to lift dirt and tarnish. The abrasive action of the salt combined with the citric acid helps restore the natural beauty and shine of the items. Rinse the item with water and buff with a soft cloth to reveal the brilliant shine.\n\nBy following these comprehensive tips, you can harness the full cleaning power of lemons to keep your home fresh, sparkling, and free from bacteria and stains. Say goodbye to harsh chemicals and embrace the natural brilliance of lemons. Happy cleaning!"
    },
    {
      name: "Meeting Notes.md",
      content: "---\nDate: 2023-09-26T22:16:00\ntags:\n  - meeting\n  - bob\nweekday: Tuesday\n---\n## Attendees:\n- Alice\n- Bob\n- Charlie\n- Daisy\n\n## Agenda:\n1. **Discuss New Coffee Machine**\n2. **Vote on Office Plants**\n3. **Brainstorm Team Outing Ideas**\n\n### Discuss New Coffee Machine:\n- Alice likes lattes\n- Bob prefers cold brew\n- Charlie's a fan of tea\n- Daisy enjoys espresso\n\n### Vote on Office Plants:\n- Alice: Cactus\n- Bob: Fern\n- Charlie: Bamboo\n- Daisy: Succulent\n\n### Brainstorm Team Outing Ideas:\n- Bowling night\n- Hiking trip\n- Movie night\n\n## Action Items:\n- [ ] Purchase coffee machine\n- [ ] Buy office plants\n- [ ] Plan team outing\n\n## Notes Prepared By:\n- Bob\n"
    },
    {
      name: "Walking Poem.md",
      content: "In the early dawn, when daylight gleams,\nA journey begins, a walk to dream.\nFootsteps upon the earth\u2019s embrace,\nInto the boundless, open space.\n\nBeneath the azure canopy above,\nGuided by whispers of a gentle dove.\nMy soul alights with each tranquil stride,\nBound to the world, I\u2019m opened wide.\n\nThrough groves and meadows, I wander free,\nThe earth, my canvas, my muse, you see.\nAs daisies sway, and the willows weep,\nI find solace in footsteps, slow and deep.\n\nThrough cobbled streets of history,\nI stroll amongst tales of reverie.\nThe past\u2019s echoes guide my way,\nUnveiling lost stories of yesterday.\n\nFootprints on sand, near the ocean's shore,\nSoft whispers of waves, beguiling more.\nThe salty breeze upon my face,\nA dance of nature, in this sacred place.\n\nUp slopes and mountains, I ascend,\nEager to conquer, to transcend.\nWith each steep climb, my spirit soars,\nCloaked by nature's abundant doors.\n\nThrough crowded cities, I navigate,\nObscured by chaos, yet radiate\nA sense of peace, a tranquil grace,\nFostering moments, without a chase.\n\nInto the woods, where silence bloomed,\nUnderneath arboreal canopy, assumed.\nWhispers of leaves, in serenade,\nA sacred symphony, nature's accolade.\n\nWalking through life, step by step,\nEach footfall closer, as dreams intercept.\nTrusting the path, as it twists and turns,\nWith newfound knowledge, my spirit yearns.\n\nFor walking uncovers hidden truth,\nAs thoughts diffuse, my heart finds youth.\nIt is in motion that I discover,\nThe world and myself, forever uncover.\n\nSo embark on journeys, in each new day,\nFor walking provides solace, come what may.\nTake time to marvel, to breathe and roam,\nFor in the rhythm of footsteps, we find our home."
    }
  ]
};

// assets/cannoliIcon.js
var cannoliIcon = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0.00 0.00 100.00 100.00">
<g stroke-width="0.4" fill="none" stroke-linecap="butt">
<path stroke="currentColor" vector-effect="non-scaling-stroke" d="
  M 55.75 12.79
  C 40.46 27.55 25.39 42.58 10.32 57.57
  Q 4.20 63.65 2.43 67.47
  C -5.88 85.44 12.97 106.07 31.72 97.48
  C 36.51 95.29 41.69 89.89 45.31 86.31
  Q 67.80 64.10 90.26 41.86
  Q 95.83 36.34 97.53 32.66
  C 106.02 14.29 86.73 -5.45 69.07 2.30
  Q 64.56 4.28 55.75 12.79"
/>
<path stroke="currentColor" vector-effect="non-scaling-stroke" d="
  M 92.27 12.95
  C 87.47 6.19 79.03 2.70 71.04 5.83
  C 67.14 7.36 66.47 10.95 65.69 14.83
  Q 63.59 25.24 61.64 35.72
  Q 61.54 36.22 62.05 36.18
  Q 76.41 34.95 90.75 33.53
  C 91.69 33.43 93.52 31.86 93.94 30.73
  Q 97.72 20.62 92.27 12.95"
/>
<path stroke="currentColor" vector-effect="non-scaling-stroke" d="
  M 12.70 60.71
  Q 12.32 61.07 12.84 60.99
  Q 28.63 58.55 44.66 55.79
  C 51.26 54.66 54.87 50.54 56.16 43.91
  Q 59.19 28.34 62.02 13.38
  Q 62.30 11.91 61.23 12.96
  L 12.70 60.71"
/>
<path stroke="currentColor" vector-effect="non-scaling-stroke" d="
  M 39.58 86.17
  L 87.89 38.49
  Q 88.52 37.87 87.64 37.95
  L 61.24 40.32
  Q 60.64 40.37 60.55 40.97
  C 58.98 51.53 54.97 59.30 43.13 60.05
  A 1.34 1.34 0.0 0 0 41.88 61.23
  L 39.00 85.89
  A 0.34 0.34 0.0 0 0 39.58 86.17"
/>
<path stroke="currentColor" vector-effect="non-scaling-stroke" d="
  M 27.50 94.60
  C 30.02 94.01 34.16 91.67 34.52 88.78
  Q 36.20 75.16 37.73 62.02
  Q 37.85 61.00 36.84 61.16
  Q 24.36 63.14 12.09 65.14
  C 6.13 66.11 3.84 72.08 4.39 77.58
  C 5.61 89.66 15.70 97.36 27.50 94.60"
/>

</g>
<path fill="currentColor" d="
  M 10.32 57.57
  C 25.39 42.58 40.46 27.55 55.75 12.79
  Q 64.56 4.28 69.07 2.30
  C 86.73 -5.45 106.02 14.29 97.53 32.66
  Q 95.83 36.34 90.26 41.86
  Q 67.80 64.10 45.31 86.31
  C 41.69 89.89 36.51 95.29 31.72 97.48
  C 12.97 106.07 -5.88 85.44 2.43 67.47
  Q 4.20 63.65 10.32 57.57
  Z
  M 92.27 12.95
  C 87.47 6.19 79.03 2.70 71.04 5.83
  C 67.14 7.36 66.47 10.95 65.69 14.83
  Q 63.59 25.24 61.64 35.72
  Q 61.54 36.22 62.05 36.18
  Q 76.41 34.95 90.75 33.53
  C 91.69 33.43 93.52 31.86 93.94 30.73
  Q 97.72 20.62 92.27 12.95
  Z
  M 12.70 60.71
  Q 12.32 61.07 12.84 60.99
  Q 28.63 58.55 44.66 55.79
  C 51.26 54.66 54.87 50.54 56.16 43.91
  Q 59.19 28.34 62.02 13.38
  Q 62.30 11.91 61.23 12.96
  L 12.70 60.71
  Z
  M 39.58 86.17
  L 87.89 38.49
  Q 88.52 37.87 87.64 37.95
  L 61.24 40.32
  Q 60.64 40.37 60.55 40.97
  C 58.98 51.53 54.97 59.30 43.13 60.05
  A 1.34 1.34 0.0 0 0 41.88 61.23
  L 39.00 85.89
  A 0.34 0.34 0.0 0 0 39.58 86.17
  Z
  M 27.50 94.60
  C 30.02 94.01 34.16 91.67 34.52 88.78
  Q 36.20 75.16 37.73 62.02
  Q 37.85 61.00 36.84 61.16
  Q 24.36 63.14 12.09 65.14
  C 6.13 66.11 3.84 72.08 4.39 77.58
  C 5.61 89.66 15.70 97.36 27.50 94.60
  Z"
/>
<path fill="none" d="
  M 12.70 60.71
  L 61.23 12.96
  Q 62.30 11.91 62.02 13.38
  Q 59.19 28.34 56.16 43.91
  C 54.87 50.54 51.26 54.66 44.66 55.79
  Q 28.63 58.55 12.84 60.99
  Q 12.32 61.07 12.70 60.71
  Z"
/>
<path fill="none" d="
  M 87.89 38.49
  L 39.58 86.17
  A 0.34 0.34 0.0 0 1 39.00 85.89
  L 41.88 61.23
  A 1.34 1.34 0.0 0 1 43.13 60.05
  C 54.97 59.30 58.98 51.53 60.55 40.97
  Q 60.64 40.37 61.24 40.32
  L 87.64 37.95
  Q 88.52 37.87 87.89 38.49
  Z"
/>
</svg>
`;

// main.ts
var DEFAULT_SETTINGS = {
  openaiAPIKey: "",
  costThreshold: 0.5,
  defaultModel: "gpt-3.5-turbo",
  defaultTemperature: 1,
  httpTemplates: [],
  includeFilenameAsHeader: false,
  includePropertiesInExtractedNotes: false,
  chatFormatString: `---
# <u>{{role}}</u>

{{content}}`,
  enableAudioTriggeredCannolis: false,
  deleteAudioFilesAfterAudioTriggeredCannolis: false,
  autoScrollWithTokenStream: false,
  pLimit: 50,
  contentIsColorless: false
};
var Cannoli = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.runningCannolis = {};
    this.createCannoliCommands = async () => {
      await new Promise((resolve) => setTimeout(resolve, 500));
      const cannoliFiles = this.app.vault.getFiles().filter((file) => {
        return file.name.includes(".cno.canvas");
      });
      cannoliFiles.forEach((file) => {
        this.createCannoliCommandForFile(file);
      });
    };
    this.createCannoliCommandForFile = async (file) => {
      this.addCommand({
        id: `run-cannoli-${file.path}`,
        name: `Run ${file.basename.slice(0, -4)}`,
        callback: async () => {
          this.startCannoli(file);
        },
        icon: "cannoli"
      });
    };
    this.createStartCommand = () => {
      this.addCommand({
        id: "start",
        name: "Start/stop cannoli",
        checkCallback: this.startCannoliCommand,
        icon: "cannoli"
      });
    };
    this.startActiveCannoliCommand = () => {
      this.startCannoliCommand(false);
    };
    this.startCannoliCommand = (checking) => {
      const activeFile = this.app.workspace.getActiveFile();
      const isMDFile = activeFile == null ? void 0 : activeFile.path.endsWith(".md");
      const isCanvasFile = activeFile == null ? void 0 : activeFile.path.endsWith(".canvas");
      if (!activeFile)
        return false;
      if (isMDFile) {
        if (checking)
          return true;
        this.app.fileManager.processFrontMatter(
          activeFile,
          (frontmatter) => {
            if (frontmatter.cannoli) {
              const filename = frontmatter.cannoli.replace("[[", "").replace("]]", "").split("|")[0];
              const file = this.app.metadataCache.getFirstLinkpathDest(
                filename,
                ""
              );
              if (!file) {
                return null;
              }
              this.startOrStopCannoli(file);
            }
          }
        );
      } else if (isCanvasFile) {
        if (checking)
          return true;
        this.startOrStopCannoli(activeFile);
      } else {
        return false;
      }
    };
    this.startOrStopCannoli = async (cannoli) => {
      if (!cannoli || !cannoli.path.endsWith(".canvas")) {
        new import_obsidian2.Notice("This file is not a canvas");
        return;
      }
      if (this.runningCannolis[cannoli.basename]) {
        this.runningCannolis[cannoli.basename].stop();
        delete this.runningCannolis[cannoli.basename];
        return;
      }
      this.startCannoli(cannoli);
    };
    this.newAudioFile = async (audio) => {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile || !activeFile.path.endsWith(".md")) {
        return;
      }
      this.app.fileManager.processFrontMatter(
        activeFile,
        async (frontmatter) => {
          if (frontmatter.cannoli) {
            const cannoliFilename = frontmatter.cannoli.replace("[[", "").replace("]]", "").split("|")[0];
            if (!cannoliFilename.endsWith(".canvas")) {
              return null;
            }
            const cannoliFile = this.app.metadataCache.getFirstLinkpathDest(
              cannoliFilename,
              ""
            );
            if (!cannoliFile) {
              return null;
            }
            await this.replaceAudioWithTranscript(activeFile, audio);
            this.startCannoli(cannoliFile);
          } else {
            return null;
          }
        }
      );
    };
    this.startCannoli = async (file) => {
      var _a2, _b, _c;
      if (this.settings.openaiAPIKey === DEFAULT_SETTINGS.openaiAPIKey) {
        new import_obsidian2.Notice(
          "Please enter your OpenAI API key in the Cannoli settings"
        );
        return;
      }
      const openai = new openai_default({
        apiKey: this.settings.openaiAPIKey,
        dangerouslyAllowBrowser: true
      });
      const name = file.basename.endsWith(".cno") ? file.basename.slice(0, -4) : file.basename;
      if (this.runningCannolis[file.basename]) {
        new import_obsidian2.Notice(`Cannoli: ${name} is already running`);
        return;
      }
      new import_obsidian2.Notice(`Started cannoli: ${name}`);
      await new Promise((resolve) => setTimeout(resolve, 1500));
      const canvas = new Canvas(file);
      await canvas.fetchData();
      const factory = new CannoliFactory(
        canvas.getCanvasData(),
        (_b = `[[${(_a2 = this.app.workspace.getActiveFile()) == null ? void 0 : _a2.basename}]]`) != null ? _b : "No active note",
        (_c = this.settings.contentIsColorless) != null ? _c : false
      );
      const graph = factory.getCannoliData();
      const shouldContinue = await this.validateCannoli(
        graph,
        file,
        name,
        canvas
      );
      if (shouldContinue) {
        await this.runCannoli(graph, file, name, canvas, openai);
      }
    };
    this.validateCannoli = async (graph, file, name, canvas, audioTranscription) => {
      return new Promise((resolve) => {
        const onFinish = (stoppage) => {
          delete this.runningCannolis[file.basename];
          if (stoppage.reason === "error") {
            new import_obsidian2.Notice(
              `Cannoli ${name} failed with the error:

${stoppage.message}`
            );
            resolve(false);
            return;
          }
          const onContinueCallback = () => {
            resolve(true);
          };
          const onCancelCallback = () => {
            resolve(false);
          };
          if (stoppage.totalCost > this.settings.costThreshold) {
            new RunPriceAlertModal(
              this.app,
              stoppage.usage,
              onContinueCallback,
              onCancelCallback
            ).open();
          } else {
            onContinueCallback();
          }
        };
        const validationGraph = new CannoliGraph2(
          JSON.parse(JSON.stringify(graph))
        );
        const validationRun = new Run({
          graph: validationGraph.graph,
          isMock: true,
          canvas,
          onFinish,
          cannoli: this
        });
        validationRun.start();
      });
    };
    this.runCannoli = async (graph, file, name, canvas, openai) => {
      return new Promise((resolve) => {
        const onFinish = (stoppage) => {
          delete this.runningCannolis[file.basename];
          let costString = "";
          if (stoppage.totalCost > 0.01) {
            costString = `
$${stoppage.totalCost.toFixed(2)}`;
          }
          if (stoppage.reason === "error") {
            new import_obsidian2.Notice(
              `Cannoli ${name} failed with the error:

${stoppage.message}${costString}`
            );
          } else if (stoppage.reason === "complete") {
            new import_obsidian2.Notice(`Cannoli complete: ${name}${costString}`);
          } else {
            new import_obsidian2.Notice(`Cannoli stopped: ${name}${costString}`);
          }
          resolve();
        };
        const liveGraph = new CannoliGraph2(
          JSON.parse(JSON.stringify(graph))
        );
        const run = new Run({
          graph: liveGraph.graph,
          openai,
          openAiConfig: {
            model: this.settings.defaultModel,
            temperature: this.settings.defaultTemperature,
            role: "user"
          },
          isMock: false,
          canvas,
          onFinish,
          cannoli: this
        });
        this.runningCannolis[file.basename] = run;
        run.start();
      });
    };
    this.addSampleFolder = async () => {
      try {
        await this.app.vault.createFolder("Cannoli College");
      } catch (error) {
        new import_obsidian2.Notice("Cannoli College folder already exists");
        return;
      }
      for (const [key, value] of Object.entries(cannoliCollege)) {
        await this.app.vault.createFolder("Cannoli College/" + key);
        for (const item of value) {
          const { name, content } = item;
          await this.app.vault.create(
            "Cannoli College/" + key + "/" + name,
            content
          );
        }
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file.name.includes(".cno.canvas")) {
          this.createCannoliCommandForFile(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file.name.includes(".cno.canvas")) {
          this.createCannoliCommandForFile(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (
          // flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
          this.settings.enableAudioTriggeredCannolis && (file.name.includes(".flac") || file.name.includes(".mp3") || file.name.includes(".mp4") || file.name.includes(".mpeg") || file.name.includes(".mpga") || file.name.includes(".m4a") || file.name.includes(".ogg") || file.name.includes(".wav") || file.name.includes(".webm"))
        ) {
          this.newAudioFile(file);
        }
      })
    );
    (0, import_obsidian2.addIcon)("cannoli", cannoliIcon);
    this.createStartCommand();
    this.createCannoliCommands();
    this.addRibbonIcon(
      "cannoli",
      "Start/stop cannoli",
      this.startActiveCannoliCommand
    );
    this.addSettingTab(new CannoliSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async replaceAudioWithTranscript(file, audio) {
    const transcript = await this.generateTranscript(audio);
    if (!transcript) {
      return;
    }
    const maxAttempts = 50;
    const delay = 100;
    let attempts = 0;
    const checkReferenceExists = async () => {
      let exists = false;
      await this.app.vault.process(file, (content) => {
        exists = content.includes(`![[${audio.name}]]`);
        return content;
      });
      return exists;
    };
    while (attempts < maxAttempts) {
      if (await checkReferenceExists()) {
        break;
      }
      await new Promise((resolve) => setTimeout(resolve, delay));
      attempts++;
    }
    if (attempts === maxAttempts) {
      return;
    }
    await this.app.vault.process(file, (content) => {
      const newContent = content.replace(
        `
![[${audio.name}]]
`,
        transcript
      );
      return newContent;
    });
    if (this.settings.deleteAudioFilesAfterAudioTriggeredCannolis) {
      this.app.vault.delete(audio);
    }
  }
  async generateTranscript(file) {
    new import_obsidian2.Notice("Transcribing audio");
    if (!file) {
      console.error("File not found");
      return;
    }
    const audioBuffer = await this.app.vault.readBinary(file);
    const N = 16;
    const randomBoundryString = "WebKitFormBoundary" + Array(N + 1).join(
      (Math.random().toString(36) + "00000000000000000").slice(
        2,
        18
      )
    ).slice(0, N);
    const pre_string = `------${randomBoundryString}\r
Content-Disposition: form-data; name="file"; filename="audio.${file.extension}"\r
Content-Type: "application/octet-stream"\r
\r
`;
    let post_string = `\r
------${randomBoundryString}\r
Content-Disposition: form-data; name="model"\r
\r
whisper-1`;
    if (this.settings.transcriptionPrompt) {
      post_string += `\r
------${randomBoundryString}\r
Content-Disposition: form-data; name="prompt"\r
\r
${this.settings.transcriptionPrompt}`;
    }
    post_string += `\r
------${randomBoundryString}--\r
`;
    const pre_string_encoded = new TextEncoder().encode(pre_string);
    const post_string_encoded = new TextEncoder().encode(post_string);
    const concatenated = await new Blob([
      pre_string_encoded,
      audioBuffer,
      post_string_encoded
    ]).arrayBuffer();
    const options = {
      url: "https://api.openai.com/v1/audio/transcriptions",
      method: "POST",
      headers: {
        "Content-Type": `multipart/form-data; boundary=----${randomBoundryString}`,
        Authorization: "Bearer " + this.settings.openaiAPIKey
      },
      body: concatenated
    };
    try {
      const response = await (0, import_obsidian2.requestUrl)(options);
      if ("text" in response.json)
        return response.json.text;
      else
        throw new Error("Error. " + JSON.stringify(response.json));
    } catch (error) {
      console.error(error);
    }
  }
};
var RunPriceAlertModal = class extends import_obsidian2.Modal {
  constructor(app, usage, onContinue, onCancel) {
    super(app);
    this.usage = Object.values(usage);
    this.onContinue = onContinue;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    let totalCost = 0;
    for (const usageItem of this.usage) {
      totalCost += usageItem.modelUsage.totalCost;
    }
    contentEl.createEl("h1", { text: "Run cost alert" });
    contentEl.createEl("p", {
      text: "Check the cost of your run before continuing"
    });
    this.usage.forEach((usage) => {
      contentEl.createEl("h2", { text: `Model: ${usage.model.name}` });
      contentEl.createEl("p", {
        text: `		Estimated prompt tokens: ${usage.modelUsage.promptTokens}`
      }).addClass("whitespace");
      contentEl.createEl("p", {
        text: `		Number of API calls: ${usage.modelUsage.apiCalls}`
      }).addClass("whitespace");
      contentEl.createEl("p", {
        text: `		Cost: $${(usage.modelUsage.promptTokens * usage.model.promptTokenPrice).toFixed(2)}`
      }).addClass("whitespace");
    });
    contentEl.createEl("h2", {
      text: `Total cost: $${totalCost.toFixed(2)}`
    });
    const panel = new import_obsidian2.Setting(contentEl);
    panel.addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
        this.onCancel();
      })
    );
    panel.addButton(
      (btn) => btn.setButtonText("Continue").setCta().onClick(() => {
        this.close();
        this.onContinue();
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var HttpTemplateEditorModal = class extends import_obsidian2.Modal {
  constructor(app, template, onSave, onCancel) {
    super(app);
    this.template = template;
    this.onSave = onSave;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("http-template-editor");
    contentEl.createEl("h1", { text: "Edit action node template" });
    const createInputGroup = (labelText, inputElement, id) => {
      const div = contentEl.createEl("div", {
        cls: "http-template-group"
      });
      const label = div.createEl("label", { text: labelText });
      label.htmlFor = id;
      inputElement.setAttribute("id", id);
      div.appendChild(inputElement);
    };
    const createDescription = (text) => {
      const p = contentEl.createEl("p", {
        cls: "http-template-description"
      });
      p.textContent = text;
      return p;
    };
    const nameInput = contentEl.createEl("input", {
      type: "text",
      value: this.template.name || ""
    });
    nameInput.setAttribute("id", "name-input");
    createInputGroup("Name:", nameInput, "name-input");
    const urlInput = contentEl.createEl("input", {
      type: "text",
      value: this.template.url || ""
    });
    urlInput.setAttribute("id", "url-input");
    createInputGroup("URL:", urlInput, "url-input");
    const methodSelect = contentEl.createEl("select");
    const methods = ["GET", "POST", "PUT", "DELETE"];
    methods.forEach((method) => {
      const option = methodSelect.createEl("option", {
        text: method,
        value: method
      });
      if (this.template.method === method) {
        option.selected = true;
      }
    });
    createInputGroup("Method:", methodSelect, "method-select");
    const headersValue = this.template.headers && Object.keys(this.template.headers).length > 0 ? JSON.stringify(this.template.headers, null, 2) : JSON.stringify(
      { "Content-Type": "application/json" },
      null,
      2
      // eslint-disable-next-line no-mixed-spaces-and-tabs
    );
    const headersInput = contentEl.createEl("textarea", {
      placeholder: `{ "Content-Type": "application/json" }`
    });
    headersInput.value = headersValue;
    headersInput.setAttribute("rows", "3");
    createInputGroup("Headers:", headersInput, "headers-input");
    const bodyTemplateInput = contentEl.createEl("textarea", {
      placeholder: "Enter body template. Use {{variableName}} for variables."
    });
    const formattedBody = this.formatBody(this.template.bodyTemplate || "");
    bodyTemplateInput.value = formattedBody;
    bodyTemplateInput.setAttribute("rows", "3");
    bodyTemplateInput.setAttribute(
      "placeholder",
      "Enter body template. Use {{variableName}} for variables."
    );
    createInputGroup(
      "Body template: (optional)",
      bodyTemplateInput,
      "body-template-input"
    );
    createDescription(
      "You can use the optional body template to predefine the structure of the request body. Use {{variableName}} syntax to insert variables into the body template. If there's only one variable, it will be replaced with whatever is written to the action node. If there are multiple variables, the action node will look for the variables in the available named arrows."
    );
    const panel = new import_obsidian2.Setting(contentEl);
    panel.addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
        this.onCancel();
      })
    );
    panel.addButton(
      (btn) => btn.setButtonText("Save").setCta().onClick(() => {
        let headers = {};
        try {
          headers = JSON.parse(headersInput.value || "{}");
        } catch (error) {
          alert(
            "Invalid JSON format for headers. Please correct and try again."
          );
          return;
        }
        this.template.name = nameInput.value;
        this.template.url = urlInput.value;
        this.template.headers = headers;
        this.template.method = methodSelect.value;
        this.template.bodyTemplate = bodyTemplateInput.value;
        this.close();
        this.onSave(this.template);
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  formatBody(body) {
    try {
      const parsedBody = JSON.parse(body);
      return JSON.stringify(parsedBody, null, 2);
    } catch (error) {
      return body;
    }
  }
};
var CannoliSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Add Cannoli College").setDesc(
      "Add a folder of sample cannolis to your vault to walk you through the basics of Cannoli. (Delete and re-add this folder to get the latest version after an update.)"
    ).addButton(
      (button) => button.setButtonText("Add").onClick(() => {
        this.plugin.addSampleFolder();
      })
    );
    containerEl.createEl("h1", { text: "LLM" });
    new import_obsidian2.Setting(containerEl).setName("OpenAI API key").setDesc(
      "This key will be used to make all openai LLM calls. Be aware that complex cannolis, especially those with many GPT-4 calls, can be expensive to run."
    ).addText(
      (text) => text.setValue(this.plugin.settings.openaiAPIKey).setPlaceholder("sk-...").onChange(async (value) => {
        this.plugin.settings.openaiAPIKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Cost threshold").setDesc(
      "If the cannoli you are about to run is estimated to cost more than this amount (USD$), you will be alerted before running it."
    ).addText(
      (text) => text.setValue(
        !isNaN(this.plugin.settings.costThreshold) ? this.plugin.settings.costThreshold.toString() : DEFAULT_SETTINGS.costThreshold.toString()
      ).onChange(async (value) => {
        if (!isNaN(parseFloat(value))) {
          this.plugin.settings.costThreshold = parseFloat(value);
          await this.plugin.saveSettings();
        } else {
          this.plugin.settings.costThreshold = DEFAULT_SETTINGS.costThreshold;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Default LLM model").setDesc(
      "This model will be used for all LLM nodes unless overridden with a config arrow. (Note that special arrow types rely on function calling, which is not available in all models.)"
    ).addText(
      (text) => text.setValue(this.plugin.settings.defaultModel).onChange(async (value) => {
        this.plugin.settings.defaultModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Default LLM temperature").setDesc(
      "This temperature will be used for all LLM nodes unless overridden with a config arrow."
    ).addText(
      (text) => text.setValue(
        !isNaN(this.plugin.settings.defaultTemperature) && this.plugin.settings.defaultTemperature ? this.plugin.settings.defaultTemperature.toString() : DEFAULT_SETTINGS.defaultTemperature.toString()
      ).onChange(async (value) => {
        if (!isNaN(parseFloat(value))) {
          this.plugin.settings.defaultTemperature = parseFloat(value);
          await this.plugin.saveSettings();
        } else {
          this.plugin.settings.defaultTemperature = DEFAULT_SETTINGS.defaultTemperature;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("LLM call concurrency limit (pLimit)").setDesc(
      "The maximum number of LLM calls that can be made at once. Decrease this if you are running into rate limiting issues."
    ).addText(
      (text) => text.setValue(
        Number.isInteger(this.plugin.settings.pLimit) ? this.plugin.settings.pLimit.toString() : DEFAULT_SETTINGS.pLimit.toString()
      ).onChange(async (value) => {
        if (!isNaN(parseInt(value)) && parseInt(value) > 0) {
          this.plugin.settings.pLimit = parseInt(value);
          await this.plugin.saveSettings();
        } else {
          this.plugin.settings.pLimit = DEFAULT_SETTINGS.pLimit;
          await this.plugin.saveSettings();
        }
      })
    );
    containerEl.createEl("h1", { text: "Canvas preferences" });
    new import_obsidian2.Setting(containerEl).setName("Parse colorless nodes as content nodes").setDesc(
      "Toggle this if you'd like colorless (grey) nodes to be interpreted as content nodes rather than call nodes. Purple nodes will then be interpreted as call nodes."
    ).addToggle(
      (toggle) => {
        var _a2;
        return toggle.setValue(
          (_a2 = this.plugin.settings.contentIsColorless) != null ? _a2 : DEFAULT_SETTINGS.contentIsColorless
        ).onChange(async (value) => {
          this.plugin.settings.contentIsColorless = value;
          await this.plugin.saveSettings();
        });
      }
    );
    containerEl.createEl("h1", { text: "Note extraction" });
    new import_obsidian2.Setting(containerEl).setName(
      "Include filenames as headers in extracted notes by default"
    ).setDesc(
      `When extracting a note in a cannoli, include the filename as a top-level header. This default can be overridden by adding "#" or "!#" after the note link in a reference like this: {{[[Stuff]]#}} or {{[[Stuff]]!#}}.`
    ).addToggle(
      (toggle) => toggle.setValue(
        this.plugin.settings.includeFilenameAsHeader || false
      ).onChange(async (value) => {
        this.plugin.settings.includeFilenameAsHeader = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName(
      "Include properties when extracting or editing notes by default"
    ).setDesc(
      `When extracting or editing a note in a cannoli, include the note's properties (YAML frontmatter). This default can be overridden by adding "^" or "!^" after the note link in a reference like this: {{[[Stuff]]^}} or {{[[Stuff]]!^}}.`
    ).addToggle(
      (toggle) => toggle.setValue(
        this.plugin.settings.includePropertiesInExtractedNotes || false
      ).onChange(async (value) => {
        this.plugin.settings.includePropertiesInExtractedNotes = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h1", { text: "Chat cannolis" });
    new import_obsidian2.Setting(containerEl).setName("Chat format string").setDesc(
      "This string will be used to format chat messages when using chat arrows. This string must contain the placeholders {{role}} and {{content}}, which will be replaced with the role and content of the message, respectively."
    ).addTextArea(
      (text) => text.setValue(this.plugin.settings.chatFormatString).onChange(async (value) => {
        const rolePlaceholder = "{{role}}";
        const contentPlaceholder = "{{content}}";
        if (!value.includes(rolePlaceholder) || !value.includes(contentPlaceholder)) {
          alert(
            `Invalid format string. Please include both ${rolePlaceholder} and ${contentPlaceholder}.`
          );
          return;
        }
        this.plugin.settings.chatFormatString = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Auto-scroll with token stream").setDesc(
      "Move the cursor forward every time a token is streamed in from a chat arrow. This will lock the scroll position to the bottom of the note."
    ).addToggle(
      (toggle) => toggle.setValue(
        this.plugin.settings.autoScrollWithTokenStream || false
      ).onChange(async (value) => {
        this.plugin.settings.autoScrollWithTokenStream = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h1", { text: "Transcription" });
    new import_obsidian2.Setting(containerEl).setName("Enable audio recorder triggered cannolis").setDesc(
      `Enable cannolis to be triggered by audio recordings. When you make a recording in a note with a cannoli property: (1) The audio file will be transcribed using Whisper. (2) The file reference will be replaced with the transcript. (3) The cannoli defined in the property will run.`
    ).addToggle(
      (toggle) => toggle.setValue(
        this.plugin.settings.enableAudioTriggeredCannolis || false
      ).onChange(async (value) => {
        this.plugin.settings.enableAudioTriggeredCannolis = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.enableAudioTriggeredCannolis) {
      new import_obsidian2.Setting(containerEl).addTextArea(
        (text) => text.setPlaceholder(
          "Enter prompt to improve transcription accuracy"
        ).setValue(
          this.plugin.settings.transcriptionPrompt || ""
        ).onChange(async (value) => {
          this.plugin.settings.transcriptionPrompt = value;
          await this.plugin.saveSettings();
        })
      ).setName("Transcription prompt").setDesc(
        "Use this prompt to guide the style and vocabulary of the transcription. (i.e. the level of punctuation, format and spelling of uncommon words in the prompt will be mimicked in the transcription)"
      );
      new import_obsidian2.Setting(containerEl).setName("Delete audio files after transcription").setDesc(
        "After a recording is transcribed, delete the audio file."
      ).addToggle(
        (toggle) => toggle.setValue(
          this.plugin.settings.deleteAudioFilesAfterAudioTriggeredCannolis || false
          // eslint-disable-next-line no-mixed-spaces-and-tabs
        ).onChange(async (value) => {
          this.plugin.settings.deleteAudioFilesAfterAudioTriggeredCannolis = value;
          await this.plugin.saveSettings();
        })
      );
    }
    containerEl.createEl("h1", { text: "Action nodes" });
    new import_obsidian2.Setting(containerEl).setName("Action node templates").setDesc("Manage default HTTP templates for action nodes.").addButton(
      (button) => button.setButtonText("+ Template").onClick(() => {
        const newCommand = {
          name: "",
          url: "",
          headers: {},
          id: "",
          method: "GET"
        };
        new HttpTemplateEditorModal(
          this.app,
          newCommand,
          (command) => {
            this.plugin.settings.httpTemplates.push(command);
            this.plugin.saveSettings();
            this.display();
          },
          () => {
          }
        ).open();
      })
    );
    for (const template of this.plugin.settings.httpTemplates) {
      new import_obsidian2.Setting(containerEl).setName(template.name).addButton(
        (button) => button.setButtonText("Edit").onClick(() => {
          new HttpTemplateEditorModal(
            this.app,
            template,
            (updatedTemplate) => {
              Object.assign(template, updatedTemplate);
              this.plugin.saveSettings();
              this.display();
            },
            () => {
            }
          ).open();
        })
      ).addButton(
        (button) => button.setButtonText("Delete").onClick(() => {
          const index = this.plugin.settings.httpTemplates.indexOf(
            template
          );
          if (index > -1) {
            this.plugin.settings.httpTemplates.splice(index, 1);
            this.plugin.saveSettings();
            this.display();
          }
        })
      );
    }
  }
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
